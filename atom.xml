<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Higher Order]]></title>
  <link href="http://runarorama.github.com/atom.xml" rel="self"/>
  <link href="http://runarorama.github.com/"/>
  <updated>2016-04-04T11:09:39-04:00</updated>
  <id>http://runarorama.github.com/</id>
  <author>
    <name><![CDATA[Rúnar Bjarnason]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Comonad of Graph Decompositions]]></title>
    <link href="http://runarorama.github.com/blog/2016/04/02/a-comonad-of-graph-decompositions/"/>
    <updated>2016-04-02T13:02:54-04:00</updated>
    <id>http://runarorama.github.com/blog/2016/04/02/a-comonad-of-graph-decompositions</id>
    <content type="html"><![CDATA[<p>I want to talk about a comonad that came up at <a href="http://innovation.verizon.com/">work</a> the other day. Actually, two of them, as the data structure in question is a comonad in at least two ways, and the issue that came up is related to the difference between those two comonads.</p>

<p>This post is sort of a continuation of the <a href="http://blog.higher-order.com/blog/2015/06/23/a-scala-comonad-tutorial/">Comonad Tutorial</a>, and we can call this &ldquo;part 3&rdquo;. I&rsquo;m going to assume the reader has a basic familiarity with comonads.</p>

<h2>Inductive Graphs</h2>

<p>At <a href="http://innovation.verizon.com/">work</a>, we develop and use a Scala library called <a href="http://github.com/oncue/quiver">Quiver</a> for working with <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics">graphs</a>). In this library, a graph is a recursively defined immutable data structure. A graph, with node IDs of type <code>V</code>, node labels <code>N</code>, and edge labels <code>E</code>, is constructed in one of two ways. It can be empty:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Or it can be of the form <code>c &amp; g</code>, where <code>c</code> is the <em>context</em> of one node of the graph and <code>g</code> is the rest of the graph with that node removed:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Context</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span>
</span><span class='line'>  <span class="n">inEdges</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[(</span><span class="kt">E</span>,<span class="kt">V</span><span class="o">)],</span>
</span><span class='line'>  <span class="n">vertex</span><span class="k">:</span> <span class="kt">V</span><span class="o">,</span>
</span><span class='line'>  <span class="n">label</span><span class="k">:</span> <span class="kt">N</span><span class="o">,</span>
</span><span class='line'>  <span class="n">outEdges</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[(</span><span class="kt">E</span>,<span class="kt">V</span><span class="o">)]</span>
</span><span class='line'><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">&amp;(</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>By the same token, we can decompose a graph on a particular node:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span>
</span><span class='line'><span class="n">v</span><span class="k">:</span> <span class="kt">V</span>
</span><span class='line'>
</span><span class='line'><span class="n">g</span> <span class="n">decomp</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Where a <code>GDecomp</code> is a <code>Context</code> for the node <code>v</code> (if it exists in the graph) together with the rest of the graph:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">Context</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">],</span> <span class="n">rest</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Recursive decomposition</h2>

<p>Let&rsquo;s say we start with a graph <code>g</code>, like this:</p>

<p><img src="http://runarorama.github.com/images/quiver/Quiver1.png" width="300" alt="Example graph" /></p>

<p>I&rsquo;m using an <em>undirected</em> graph here for simplification. An undirected graph is one in which the edges don&rsquo;t have a direction. In Quiver, this is represented as a graph where the &ldquo;in&rdquo; edges of each node are the same as its &ldquo;out&rdquo; edges.</p>

<p>If we decompose on the node <code>a</code>, we get a view of the graph from the perspective of <code>a</code>. That is, we&rsquo;ll have a <code>Context</code> letting us look at the label, vertex ID, and edges to and from <code>a</code>, and we&rsquo;ll also have the remainder of the graph, with the node <code>a</code> &ldquo;broken off&rdquo;:</p>

<p><img src="http://runarorama.github.com/images/quiver/decompa.png" width="400" alt="GDecomp on a" /></p>

<p>Quiver can arbitrarily choose a node for us, so we can look at the context of some &ldquo;first&rdquo; node:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">g</span><span class="o">.</span><span class="n">decompAny</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can keep decomposing the remainder recursively, to perform an arbitrary calculation over the entire graph:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">Context</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">],</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span>
</span><span class='line'><span class="n">b</span><span class="k">:</span> <span class="kt">B</span>
</span><span class='line'>
</span><span class='line'><span class="o">(</span><span class="n">g</span> <span class="n">fold</span> <span class="n">b</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>The implementation of <code>fold</code> will be something like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">g</span><span class="o">.</span><span class="n">decompAny</span> <span class="n">map</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">GDecomp</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">rest</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">b</span><span class="o">)(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span> <span class="n">getOrElse</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>For instance, if we wanted to count the edges in the graph <code>g</code>, we could do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">g</span> <span class="n">fold</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="nc">Context</span><span class="o">(</span><span class="n">ins</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">outs</span><span class="o">),</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ins</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">outs</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">b</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The recursive decomposition will guarantee that our function doesn&rsquo;t see any given edge more than once. For the graph <code>g</code> above, <code>(g fold b)(f)</code> would look something like this:</p>

<p><img src="http://runarorama.github.com/images/quiver/fold.png" alt="Graph fold" /></p>

<h2>Graph Rotations</h2>

<p>Let&rsquo;s now say that we wanted to find the maximum <a href="https://en.wikipedia.org/wiki/Degree_(graph_theory">degree</a> of a graph. That is, find the highest number of edges to or from any node.</p>

<p>A first stab might be:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">maxDegree</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">g</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="nc">Context</span><span class="o">(</span><span class="n">ins</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">outs</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">ins</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">outs</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="n">max</span> <span class="n">z</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But that would get the incorrect result. In our graph <code>g</code> above, the nodes <code>b</code>, <code>d</code>, and <code>f</code> have a degree of 3, but this fold would find the highest degree to be 2. The reason is that once our function gets to look at <code>b</code>, its edge to <code>a</code> has already been removed, and once it sees <code>f</code>, it has no edges left to look at.</p>

<p>This was the issue that came up at work. This behaviour of <code>fold</code> is both correct and useful, but it can be surprising. What we might expect instead is that instead of receiving successive decompositions, our function sees &ldquo;all rotations&rdquo; of the graph through the <code>decomp</code> operator:</p>

<p><img src="http://runarorama.github.com/images/quiver/rotations.png" alt="All rotations" /></p>

<p>That is, we often want to consider each node in the context of the entire graph we started with. In order to express that with <code>fold</code>, we have to decompose the original graph at each step:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">maxDegree</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">g</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="n">g</span><span class="o">.</span><span class="n">decompose</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">vertex</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">GDecomp</span><span class="o">(</span><span class="nc">Context</span><span class="o">(</span><span class="n">ins</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">outs</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>        <span class="n">ins</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">outs</span><span class="o">.</span><span class="n">size</span>
</span><span class='line'>    <span class="o">}.</span><span class="n">getOrElse</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="n">max</span> <span class="n">z</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But what if we could have a combinator that <em>labels each node with its context</em>?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">contextGraph</span><span class="o">(</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">Context</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span>,<span class="kt">E</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Visually, that looks something like this:</p>

<p><img src="http://runarorama.github.com/images/quiver/duplicate.png" alt="All contexts" /></p>

<p>If we now fold over <code>contextGraph(g)</code> rather than <code>g</code>, we get to see the whole graph from the perspective of each node in turn. We can then write the <code>maxDegree</code> function like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">maxDegree</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">contextGraph</span><span class="o">(</span><span class="n">g</span><span class="o">).</span><span class="n">fold</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="n">z</span> <span class="n">max</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">ins</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">outs</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Two different comonads</h2>

<p>This all sounds suspiciously like a comonad! Of course, <code>Graph</code> itself is not a comonad, but <code>GDecomp</code> definitely is. The <code>counit</code> just gets the label of the node that&rsquo;s been <code>decomp</code>ed out:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">gdecompComonad</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">λ</span><span class="o">[</span><span class="kt">α</span> <span class="k">=&gt;</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">α</span>,<span class="kt">E</span><span class="o">]]]</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">label</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">cobind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">])(</span>
</span><span class='line'>                  <span class="n">f</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>cobind</code> can be implemented in one of two ways. There&rsquo;s the &ldquo;successive decompositions&rdquo; version:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">cobind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">])(</span>
</span><span class='line'>                <span class="n">f</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">GDecomp</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">g</span><span class="o">)),</span>
</span><span class='line'>          <span class="n">g</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">decompAny</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="nc">GDecomp</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=</span> <span class="n">cobind</span><span class="o">(</span><span class="k">_</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'>            <span class="n">c</span> <span class="o">&amp;</span> <span class="n">r</span>
</span><span class='line'>          <span class="o">}</span> <span class="n">getOrElse</span> <span class="n">empty</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Visually, it looks like this:</p>

<p><img src="http://runarorama.github.com/images/quiver/extend.png" alt="Extend over successive decompositions" /></p>

<p>It <em>exposes the substructure</em> of the graph by storing it in the labels of the nodes. It&rsquo;s very much like the familiar <code>NonEmptyList</code> comonad, which replaces each element in the list with the whole sublist from that element on.</p>

<p>So this is the comonad of <em>recursive folds over a graph</em>. Really its action is the same as as just <code>fold</code>. It takes a computation on one decomposition of the graph, and extends it to all sub-decompositions.</p>

<p>But there&rsquo;s another, comonad that&rsquo;s much more useful <em>as a comonad</em>. That&rsquo;s the comonad that works like <code>contextGraph</code> from before, except instead of copying the context of a node into its label, we copy the whole decomposition; both the context and the remainder of the graph.</p>

<p>That one looks visually more like this:</p>

<p><img src="http://runarorama.github.com/images/quiver/redecorate.png" alt="Extend over all rotations" /></p>

<p>Its <code>cobind</code> takes a computation focused on one node of the graph (that is, on a <code>GDecomp</code>), repeats that for every other decomposition of the original graph in turn, and stores the results in the respective node labels:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">cobind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">])(</span>
</span><span class='line'>                <span class="n">f</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">orig</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ctx</span> <span class="o">&amp;</span> <span class="n">g</span><span class="o">.</span><span class="n">rest</span>
</span><span class='line'>  <span class="nc">GDecomp</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">g</span><span class="o">)),</span>
</span><span class='line'>          <span class="n">rest</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">empty</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>            <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">orig</span><span class="o">.</span><span class="n">decomp</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">vertex</span><span class="o">).</span><span class="n">get</span><span class="o">))</span> <span class="o">&amp;</span> <span class="n">acc</span>
</span><span class='line'>          <span class="o">})</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is useful for algorithms where we want to label every node with some information computed from its neighborhood. For example, some clustering algorithms start by assigning each node its own cluster, then repeatedly joining nodes to the most popular cluster in their immediate neighborhood, until a fixed point is reached.</p>

<p>As a simpler example, we could take the average value for the labels of neighboring nodes, to apply something like a low-pass filter to the whole graph:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">lopass</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">E</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">Int</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">Int</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">g</span><span class="o">.</span><span class="n">decompAny</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">d</span> <span class="k">=&gt;</span> <span class="n">cobind</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">neighbors</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">inEdges</span> <span class="o">++</span> <span class="n">x</span><span class="o">.</span><span class="n">outEdges</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">n</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="n">g</span><span class="o">.</span><span class="n">decomp</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">label</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">sum</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}}</span> <span class="n">getOrElse</span> <span class="n">g</span>
</span></code></pre></td></tr></table></div></figure>


<p>The difference between these two comonad instances is essentially the same as the difference between <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/NonEmptyList.scala"><code>NonEmptyList</code></a> and the nonempty list <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Zipper.scala"><code>Zipper</code></a>.</p>

<p>It&rsquo;s this latter &ldquo;decomp zipper&rdquo; comonad that I decided to ultimately include as the <code>Comonad</code> instance for <code>quiver.GDecomp</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Freedom and Forgetfulness]]></title>
    <link href="http://runarorama.github.com/blog/2015/10/12/freedom-and-forgetfulness/"/>
    <updated>2015-10-12T23:13:54-04:00</updated>
    <id>http://runarorama.github.com/blog/2015/10/12/freedom-and-forgetfulness</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been having fun exploring adjunctions lately and thinking about how we can take a monad apart and compose it the other way to get a comonad, and vice versa. Often I&rsquo;ll find that a comonad counterpart of a given monad gives an interesting perspective on that monad, and ditto for a monad cousin to a given comonad.</p>

<h2>The monad for monoids</h2>

<p>Let&rsquo;s take an example. There is a category of monoids <em>Mon</em> with monoids as objects and monoid homomorphisms as arrows between them. Then there is a functor from <em>Set</em> to <em>Mon</em> that takes any ordinary type <code>A</code> to the <em>free monoid</em> generated by <code>A</code>. This is just the <code>List[A]</code> type together with concatenation as the multiplication and the empty list as the identity element.</p>

<p>This free functor has a right adjoint that takes any monoid <code>M</code> in <em>Mon</em> to its <em>underlying set</em> <code>M</code>. That is, this right adjoint &ldquo;forgets&rdquo; that <code>M</code> is a monoid, leaving us with just an ordinary type.</p>

<p>If we compose these two functors, we get a monad. If we start with a type <code>A</code>, get its free monoid (the <code>List[A]</code> monoid), and then go from there to the underlying type of the free monoid, we end up with the type <code>List[A]</code>. The <code>unit</code> of our adjunction is then a function from any given type <code>A</code> to the type <code>List[A]</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Structure ⊣ Interpretation</h3>

<p>But then what is the <code>counit</code>? Remember that for any adjunction, we can compose the functors one way to get a monad, and compose them the other way to get a comonad.</p>

<p>In that case we have to start with a monoid <code>M</code>, then &ldquo;forget&rdquo;, giving us the plain type <code>M</code>. Then we take the free monoid of that to end up with the <code>List[M]</code> monoid.</p>

<p>But notice that we are now in the monoid category. In that category, <code>List</code> is a comonad. And since we&rsquo;re in the category of monoids, the <code>counit</code> has to be a <em>monoid homomorphism</em>. It goes from the free monoid <code>List[A]</code> to the monoid <code>A</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A:Monoid</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">as</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">zero</span><span class="o">)(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">append</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If we send the <code>counit</code> for this comonad over to the <em>Set</em> category, we get the <code>join</code> for our monad:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">counit</span><span class="o">(</span><span class="n">as</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>And to get the <code>duplicate</code> or <code>extend</code> operation in the comonad, we just turn the crank on the adjunction:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">duplicate</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">as</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">unit</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>duplicate</code> just puts each element into its own sublist. With regard to <code>extend</code>, this just means that given any catamorphism on <code>List</code>, we can turn that into a homomorphism on free monoids.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">extend</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">as</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">unit</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>All the interesting parts of <code>List</code> are the parts that make it a monoid, and our comonad here is already in a category full of monoids. Therefore the coKleisli composition in this comonad is kind of uninteresting. All it&rsquo;s saying is that if we can fold a <code>List[A]</code> to a <code>B</code>, and a <code>List[B]</code> to a <code>C</code>, then we can fold a <code>List[A]</code> to a <code>C</code>, by considering each element as a singleton list.</p>

<h2>Forget ⊣ Cofree</h2>

<p>Let&rsquo;s now consider another category, call it <em>End(Set)</em>, which is the <em>category of endofunctors</em> in <em>Set</em>.</p>

<p>The arrows in this category are natural transformations:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">~&gt;</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>There&rsquo;s another category, <em>Com</em>, which is the <em>category of comonads</em> on <em>Set</em>. The arrows here are <em>comonad homomorphisms</em>. A comonad homomorphism from <code>F</code> to <code>G</code> is a natural transformation <code>f: F ~&gt; G</code> satisfying the homomorphism law:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="n">duplicate</span> <span class="o">==</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">duplicate</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span>
</span></code></pre></td></tr></table></div></figure>


<p>There is a forgetful functor <code>Forget: Com -&gt; End(Set)</code> that takes a comonad to its underlying endofunctor (forgetting that it&rsquo;s a comonad). And this functor has a <em>right</em> adjoint <code>Cofree: End(Set) -&gt; Com</code> which generates a cofree comonad on a given endofunctor <code>F</code>. This is the following data type:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cofree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that not only is the endofunctor <code>Cofree[F,?]</code> a comonad (in <em>Set</em>) for any functor <code>F</code>, but the higher-order type constructor <code>Cofree</code> is itself is a comonad in the endofunctor category. It&rsquo;s this latter comonad that is induced by the <code>Forget ⊣ Cofree</code> adjunction. That is, we start at an endofunctor <code>F</code>, then go to comonads via <code>Cofree[F,?]</code>, then back to endofunctors via <code>Forget</code>.</p>

<p>The <code>unit</code> for this adjunction is then a comonad homomorphism. Remember, this is the <code>unit</code> for a monad in the category <em>Com</em> of comonads:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Comonad</span>,<span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">Cofree</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">counit</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="o">(</span><span class="n">unit</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This will start with a value of type <code>F[A]</code> in the comonad <code>F</code>, and then <em>unfold</em> an <code>F</code>-branching stream from it. Note that the first level of this will have the same structure as <code>x</code>.</p>

<p>If we take <code>unit</code> across to the <em>End(Set)</em> category, we get the <code>duplicate</code> for our comonad:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">duplicate</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Cofree</span><span class="o">[</span><span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">?</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">unit</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that this is <em>not</em> the <code>duplicate</code> for the <code>Cofree[F,?]</code> comonad. It&rsquo;s the duplicate for <code>Cofree</code> itself which is a comonad in an endofunctor category.</p>

<p>Turning the crank on the adjunction, the <code>counit</code> for this comonad now has to be the inverse of our <code>unit</code>. It takes the heads of all the branches of the given <code>F</code>-branching stream.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">A</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">c</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Sending that over to the comonad category, we get the <code>join</code> for our monad:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Comonad</span>,<span class="kt">A</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Cofree</span><span class="o">[</span><span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">?</span><span class="o">]</span>,<span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">counit</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala Comonad Tutorial, Part 2]]></title>
    <link href="http://runarorama.github.com/blog/2015/10/04/scala-comonad-tutorial-part-2/"/>
    <updated>2015-10-04T17:36:31-04:00</updated>
    <id>http://runarorama.github.com/blog/2015/10/04/scala-comonad-tutorial-part-2</id>
    <content type="html"><![CDATA[<p>In the <a href="http://blog.higher-order.com/blog/2015/06/23/a-scala-comonad-tutorial/">previous post</a>, we looked at the Reader/Writer monads and comonads, and discussed in general what comonads are and how they relate to monads. This time around, we&rsquo;re going to look at some more comonads, delve briefly into adjunctions, and try to get some further insight into what it all means.</p>

<h2>Nonempty structures</h2>

<p>Since a comonad has to have a <code>counit</code>, it must be &ldquo;pointed&rdquo; or nonempty in some sense. That is, given a value of type <code>W[A]</code> for some comonad <code>W</code>, we must be able to get a value of type <code>A</code> out.</p>

<p>The identity comonad is a simple example of this. We can always get a value of type <code>A</code> out of <code>Id[A]</code>. A slightly more interesting example is that of non-empty lists:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">NEL</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">NEL</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</span></code></pre></td></tr></table></div></figure>


<p>So a nonempty list is a value of type <code>A</code> together with either another list or <code>None</code> to mark that the list has terminated. Unlike the traditional <code>List</code> data structure, we can always safely get the <code>head</code>.</p>

<p>But what is the comonadic <code>duplicate</code> operation here? That should allow us to go from <code>NEL[A]</code> to <code>NEL[NEL[A]]</code> in such a way that the comonad laws hold. For nonempty lists, an implementation that satisfies those laws turns out to be:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">NEL</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">NEL</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">tails</span><span class="k">:</span> <span class="kt">NEL</span><span class="o">[</span><span class="kt">NEL</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">NEL</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tail</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">tails</span><span class="o">))</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>tails</code> operation returns a list of all the suffixes of the given list. This list of lists is always nonempty, because the first suffix is the list itself. For example, if we have the nonempty list <code>[1,2,3]</code> (to use a more succinct notation), the <code>tails</code> of that will be <code>[[1,2,3], [2,3], [3]]</code></p>

<p>To get an idea of what this <em>means</em> in the context of a comonadic program, think of this in terms of coKleisli composition, or <code>extend</code> in the comonad:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">extend</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">NEL</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">NEL</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">tails</span> <span class="n">map</span> <span class="n">f</span>
</span></code></pre></td></tr></table></div></figure>


<p>When we <code>map</code> over <code>tails</code>, the function <code>f</code> is going to receive each suffix of the list in turn. We apply <code>f</code> to each of those suffixes and collect the results in a (nonempty) list. So <code>[1,2,3].extend(f)</code> will be <code>[f([1,2,3]), f([2,3]), f([3])]</code>.</p>

<p>The name <code>extend</code> refers to the fact that it takes a &ldquo;local&rdquo; computation (here a computation that operates on a list) and extends that to a &ldquo;global&rdquo; computation (here over all suffixes of the list).</p>

<p>Or consider this class of nonempty trees (often called Rose Trees):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">tip</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">sub</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</span></code></pre></td></tr></table></div></figure>


<p>A tree of this sort has a value of type <code>A</code> at the tip, and a (possibly empty) list of subtrees underneath. One obvious use case is something like a directory structure, where each <code>tip</code> is a directory and the corresponding <code>sub</code> is its subdirectories.</p>

<p>This is also a comonad. The <code>counit</code> is obvious, we just get the <code>tip</code>. And here&rsquo;s a <code>duplicate</code> for this structure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">Tree</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Tree</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">sub</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">duplicate</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, this obviously gives us a tree of trees, but what is the structure of that tree? It will be <em>a tree of all the subtrees</em>. The <code>tip</code> will be <code>this</code> tree, and the <code>tip</code> of each proper subtree under it will be the entire subtree at the corresponding point in the original tree.</p>

<p>That is, when we say <code>t.duplicate.map(f)</code> (or equivalently <code>t extend f</code>), our <code>f</code> will receive each subtree of <code>t</code> in turn and perform some calculation over that entire subtree. The result of the whole expression <code>t extend f</code> will be a tree mirroring the structure of <code>t</code>, except each node will contain <code>f</code> applied to the corresponding subtree of <code>t</code>.</p>

<p>To carry on with our directory example, we can imagine wanting a detailed space usage summary of a directory structure, with the size of the whole tree at the <code>tip</code> and the size of each subdirectory underneath as tips of the subtrees, and so on. Then <code>d extend size</code> creates the tree of sizes of recursive subdirectories of <code>d</code>.</p>

<h2>The cofree comonad</h2>

<p>You may have noticed that the implementations of <code>duplicate</code> for rose trees and <code>tails</code> for nonempty lists were basically identical. The only difference is that one is mapping over a <code>List</code> and the other is mapping over an <code>Option</code>. We can actually abstract that out and get a comonad for any functor <code>F</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cofree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">counit</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">sub</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]])</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">Cofree</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Cofree</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">sub</span><span class="o">)(</span><span class="k">_</span><span class="o">.</span><span class="n">duplicate</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>A really common kind of structure is something like the type <code>Cofree[Map[K,?],A]</code> of trees where the <code>counit</code> is some kind of summary and each key of type <code>K</code> in the <code>Map</code> of subtrees corresponds to some drilldown for more detail. This kind of thing appears in portfolio management applications, for example.</p>

<p>Compare this structure with the <em>free monad</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Suspend</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>While the free monad is <em>either</em> an <code>A</code> or a recursive step suspended in an <code>F</code>, the cofree comonad is <em>both</em> an <code>A</code> <em>and</em> a recursive step suspended in an <code>F</code>. They really are duals of each other in the sense that the monad is a coproduct and the comonad is a product.</p>

<h2>Comparing comonads to monads (again)</h2>

<p>Given this difference, we can make some statements about what it means:</p>

<ul>
<li><code>Free[F,A]</code> is a type of &ldquo;leafy tree&rdquo; that branches according to <code>F</code>, with values of type <code>A</code> at the leaves, while <code>Cofree[F,A]</code> is a type of &ldquo;node-valued tree&rdquo; that branches according to <code>F</code> with values of type <code>A</code> at the nodes.</li>
<li>If <code>Exp</code> defines the structure of some expression language, then <code>Free[Exp,A]</code> is the type of abstract syntax trees for that language, with free variables of type <code>A</code>, and monadic <code>bind</code> literally binds expressions to those variables. Dually, <code>Cofree[Exp,A]</code> is the type of <em>closed</em> exresspions whose subexpressions are annotated with values of type <code>A</code>, and comonadic <code>extend</code> <em>reannotates</em> the tree. For example, if you have a type inferencer <code>infer</code>, then <code>e extend infer</code> will annotate each subexpression of <code>e</code> with its inferred type.</li>
</ul>


<p>This comparison of <code>Free</code> and <code>Cofree</code> actually says something about monads and comonads in general:</p>

<ul>
<li>All monads can model some kind of leafy tree structure, and all comonads can be modeled by some kind of node-valued tree structure.</li>
<li>In a monad <code>M</code>, if <code>f: A =&gt; M[B]</code>, then <code>xs map f</code> allows us to take the values at the leaves (<code>a:A</code>) of a monadic structure <code>xs</code> and <em>substitute</em> an entire structure (<code>f(a)</code>) for each value. A subsequent <code>join</code> then renormalizes the structure, eliminating the &ldquo;seams&rdquo; around our newly added substructures. In a <em>comonad</em> <code>W</code>, <code>xs.duplicate</code> denormalizes, or exposes the substructure of <code>xs:W[A]</code> to yield <code>W[W[A]]</code>. Then we can map a function <code>f: W[A] =&gt; B</code> over that to get a <code>B</code> for each part of the substructure and <em>redecorate</em> the original structure with those values. (See Uustalu and Vene&rsquo;s excellent paper <a href="http://cs.ioc.ee/~tarmo/papers/sfp01-book.pdf">The Dual of Substitution is Redecoration</a> for more on this connection.)</li>
<li>A monad defines a class of programs whose subexpressions are incrementally generated from the outputs of previous expressions. A comonad defines a class of programs that incrementally generate output from the substructure of previous expressions.</li>
<li>A monad adds structure by consuming values. A comonad adds values by consuming structure.</li>
</ul>


<h2>The relationship between Reader and Coreader</h2>

<p>If we look at a Kleisli arrow in the <code>Reader[R,?]</code> comonad, it looks like <code>A =&gt; Reader[R,B]</code>, or expanded out: <code>A =&gt; R =&gt; B</code>. If we uncurry that, we get <code>(A, R) =&gt; B</code>, and we can go back to the original by currying again. But notice that a value of type <code>(A, R) =&gt; B</code> is a coKleisli arrow in the <code>Coreader</code> comonad! Remember that <code>Coreader[R,A]</code> is really a pair <code>(A, R)</code>.</p>

<p>So the answer to the question of how <code>Reader</code> and <code>Coreader</code> are related is that there is a one-to-one correspondence between a Kleisli arrow in the <code>Reader</code> monad and a coKleisli arrow in the <code>Coreader</code> comonad. More precisely, the Kleisli category for <code>Reader[R,?]</code> is isomorphic to the coKleisli category for <code>Coreader[R,?]</code>. This isomorphism is witnessed by currying and uncurrying.</p>

<p>In general, if we have an isomorphism between arrows like this, we have what&rsquo;s called an <em>adjunction</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Adjunction</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">left</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">right</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In an <code>Adjunction[F,G]</code>, we say that <code>F</code> is <em>left adjoint</em> to <code>G</code>, often expressed with the notation <code>F ⊣ G</code>.</p>

<p>We can clearly make an <code>Adjunction</code> for <code>Coreader[R,?]</code> and <code>Reader[R,?]</code> by using <code>curry</code> and <code>uncurry</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">homSetAdj</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Adjunction</span><span class="o">[(</span><span class="kt">?</span>, <span class="kt">R</span><span class="o">)</span>, <span class="kt">R</span> <span class="k">=&gt;</span> <span class="kt">?</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">left</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">((</span><span class="kt">A</span><span class="o">,</span> <span class="kt">R</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span> <span class="k">=&gt;</span> <span class="n">B</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Function</span><span class="o">.</span><span class="n">untupled</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">curried</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">right</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">R</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="o">((</span><span class="kt">A</span><span class="o">,</span> <span class="kt">R</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">B</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Function</span><span class="o">.</span><span class="n">uncurried</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">tupled</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The additional <code>tupled</code> and <code>untupled</code> come from the unfortunate fact that I&rsquo;ve chosen Scala notation here and Scala differentiates between functions of two arguments and functions of one argument that happens to be a pair.</p>

<p>So a more succinct description of this relationship is that <code>Coreader</code> is left adjoint to <code>Reader</code>.</p>

<p>Generally the left adjoint functor <em>adds</em> structure, or is some kind of &ldquo;producer&rdquo;, while the right adjoint functor <em>removes</em> (or &ldquo;forgets&rdquo;) structure, or is some kind of &ldquo;consumer&rdquo;.</p>

<h2>Composing adjoint functors</h2>

<p>An interesting thing about adjunctions is that if you have an adjoint pair of functors <code>F ⊣ G</code>, then <code>F[G[?]]</code> always forms a comonad, and <code>G[F[?]]</code> always forms a monad, in a completely canonical and amazing way:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">monad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">A</span><span class="k">:</span> <span class="kt">Adjunction</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">G</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">λ</span><span class="o">[</span><span class="kt">α</span> <span class="k">=&gt;</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">α</span><span class="o">]]]]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">A</span><span class="o">.</span><span class="n">left</span><span class="o">(</span><span class="n">identity</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">G</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">A</span><span class="o">.</span><span class="n">right</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">comonad</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">A</span><span class="k">:</span> <span class="kt">Adjunction</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">G</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">λ</span><span class="o">[</span><span class="kt">α</span> <span class="k">=&gt;</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">α</span><span class="o">]]]]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span><span class='line'>      <span class="n">A</span><span class="o">.</span><span class="n">right</span><span class="o">(</span><span class="n">identity</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]])(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">extend</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>      <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">A</span><span class="o">.</span><span class="n">left</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that this says something about monads and comonads. Since the left adjoint <code>F</code> is a producer and the right adjoint <code>G</code> is a consumer, a monad always consumes and then produces, while a comonad always produces and then consumes.</p>

<p>Now, if we compose <code>Reader</code> and <code>Coreader</code>, which monad do we get?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">M</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="n">monad</span><span class="o">(</span><span class="n">homSetAdj</span><span class="o">[</span><span class="kt">S</span><span class="o">])</span>
</span><span class='line'><span class="n">M</span><span class="k">:</span> <span class="err">[</span><span class="kt">S</span><span class="err">]</span><span class="o">=&gt;</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Monad</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">S</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="kt">α</span>, <span class="kt">S</span><span class="o">)]</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s the <code>State[S,?]</code> monad!</p>

<p>Now if we compose it the other way, we should get a comonad:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">W</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="n">comonad</span><span class="o">(</span><span class="n">homSetAdj</span><span class="o">[</span><span class="kt">S</span><span class="o">])</span>
</span><span class='line'><span class="n">W</span><span class="k">:</span> <span class="err">[</span><span class="kt">S</span><span class="err">]</span><span class="o">=&gt;</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Comonad</span><span class="o">[[</span><span class="kt">α</span><span class="o">](</span><span class="kt">S</span> <span class="k">=&gt;</span> <span class="kt">α</span>, <span class="kt">S</span><span class="o">)]</span>
</span></code></pre></td></tr></table></div></figure>


<p>What is that? It&rsquo;s the <code>Store[S,?]</code> comonad:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Store</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">peek</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">cursor</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">extract</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">peek</span><span class="o">(</span><span class="n">cursor</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">extend</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Store</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Store</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Store</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="nc">Store</span><span class="o">(</span><span class="n">peek</span><span class="o">,</span> <span class="n">s</span><span class="o">)),</span> <span class="n">cursor</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="k">:</span> <span class="kt">Store</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Store</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">extend</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Store</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">extend</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">extract</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">seek</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span> <span class="n">duplicate</span><span class="o">.</span><span class="n">peek</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This models a &ldquo;store&rdquo; of values of type <code>A</code> indexed by the type <code>S</code>. We have the ability to directly access the <code>A</code> value under a given <code>S</code> using <code>peek</code>, and there is a distinguished <code>cursor</code> or current position. The comonadic <code>extract</code> just reads the value under the <code>cursor</code>, and <code>duplicate</code> gives us a whole store full of stores such that if we <code>peek</code> at any one of them, we get a <code>Store</code> whose <code>cursor</code> is set to the given <code>s</code>. We&rsquo;re defining a <code>seek(s)</code> operation that moves the <code>cursor</code> to a given position <code>s</code> by taking advantage of <code>duplicate</code>.</p>

<p>A use case for this kind of structure might be something like image processing or cellular automata, where <code>S</code> might be coordinates into some kind of space (like a two-dimensional image). Then <code>extend</code> takes a local computation at the <code>cursor</code> and extends it to every point in the space. For example, if we have an operation <code>average</code> that peeks at the <code>cursor</code>&rsquo;s immediate neighbors and averages them, then we can apply a low-pass filter to the whole image with <code>image.extend(average)</code>.</p>

<p>The type <code>A =&gt; Store[S,B]</code> is also one possible representation of a <a href="http://docs.typelevel.org/api/scalaz/stable/7.1.0-M3/doc/#scalaz.package%24%24Lens%24">Lens</a>. I might talk about lenses and <a href="http://docs.typelevel.org/api/scalaz/stable/7.1.0-M3/doc/#scalaz.Zipper">zippers</a> in a future post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[An Adjunction That Induces the Reader Monad]]></title>
    <link href="http://runarorama.github.com/blog/2015/09/30/the-adjunction-that-induces-the-reader-monad/"/>
    <updated>2015-09-30T07:48:13-04:00</updated>
    <id>http://runarorama.github.com/blog/2015/09/30/the-adjunction-that-induces-the-reader-monad</id>
    <content type="html"><![CDATA[<p>In writing up part 2 of my <a href="http://blog.higher-order.com/blog/2015/06/23/a-scala-comonad-tutorial/">Scala Comonad Tutorial</a>, and coming up with my talk for <a href="http://scala.world">Scala World</a>, I idly pondered this question:</p>

<blockquote><p>If all monads are given by composing adjoint pairs of functors, what adjoint pair of functors forms the `Reader` monad? And if we compose those functors the other way, which comonad do we get?</p></blockquote>


<p>Shachaf Ben-Kiki pointed out on IRC that there are at least two ways of doing this. One is via the <a href="https://en.wikipedia.org/wiki/Kleisli_category#Kleisli_adjunction">Kleisli construction</a> and the other is via the <a href="http://ncatlab.org/nlab/show/Eilenberg-Moore+category">Eilenberg-Moore construction</a>. Dr Eugenia Cheng has a <a href="https://www.youtube.com/playlist?list=PL54B49729E5102248">fantastic set of videos explaining these constructions</a>. She talks about how for any monad <code>T</code> there is a whole category <code>Adj(T)</code> of adjunctions that give rise to <code>T</code> (with categories as objects and adjoint pairs of functors as the arrows), and the Kleisli category is the initial object in this category while the Eilenberg-Moore category is the terminal object.</p>

<p>So then, searching around for an answer to what exactly the Eilenberg-Moore category for the <code>R =&gt; ?</code> monad looks like (I think it&rsquo;s just values of type <code>R</code> and functions between them), I came across <a href="http://math.stackexchange.com/questions/1274989/what-is-the-eilenberg-moore-category-of-this-diagonal-like-monad">this Mathematics Stack Exchange question</a>, whose answer more or less directly addresses my original question above. The adjunction is a little more difficult to see than the initial/terminal ones, but it&rsquo;s somewhat interesting, and what follows is an outline of how I convinced myself that it works.</p>

<h2>The adjoint pair</h2>

<p>Let&rsquo;s consider the reader monad <code>R =&gt; ?</code>, which allows us to read a context of type <code>R</code>.</p>

<p>The first category involved is <em>Set</em> (or <em>Hask</em>, or <em>Scala</em>). This is just the familiar category where the objects are types (<code>A</code>,<code>B</code>,<code>C</code>, etc.) and the arrows are functions.</p>

<p>The other category is <em>Set/R</em>, which is the <a href="http://ncatlab.org/nlab/show/overcategory">slice category</a> of <em>Set</em> over the type <code>R</code>. This is a category whose objects are functions to <code>R</code>. So an object <code>x</code> in this category is given by a type <code>A</code> together with a function of type <code>A =&gt; R</code>. An arrow from <code>x: A =&gt; R</code> to <code>y: B =&gt; R</code> is given by a function <code>f: A =&gt; B</code> such that <code>y(f(a)) = x(a)</code> for all <code>a:A</code>.</p>

<p>The left adjoint is <code>R*</code>, a functor from <em>Set</em> to <em>Set/R</em>. This functor sends each type <code>A</code> to the function <code>(p:(R,A)) =&gt; p._1</code>, having type <code>(R,A) =&gt; R</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">rStar</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="o">(</span><span class="kt">R</span><span class="o">,</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">R</span> <span class="k">=</span> <span class="k">_</span><span class="o">.</span><span class="n">_1</span>
</span></code></pre></td></tr></table></div></figure>


<p>The right adjoint is <code>Π_R</code>, a functor from <em>Set/R</em> to <em>Set</em>. This functor sends each object <code>q: A =&gt; R</code> in <em>Set/R</em> to the set of functions <code>R =&gt; A</code> for which <code>q</code> is an inverse. This is actually a dependent type inhabited by functions <code>p: R =&gt; A</code> which satisfy the identity <code>q(p(a)) = a</code> for all <code>a:A</code>.</p>

<h2>Constructing the monad</h2>

<p>The monad is not exactly easy to see, but if everything has gone right, we should get the <code>R =&gt; ?</code> reader monad by composing <code>Π_R</code> with <code>R*</code>.</p>

<p>We start with a type <code>A</code>. Then we do <code>R*</code>, which gives us the object <code>rStar[A]</code> in the slice category, which you will recall is just <code>_._1</code> of type <code>(R,A) =&gt; R</code>. Then we go back to types via <code>Π_R(rStar[A])</code> which gives us a dependent type <code>P</code> inhabited by functions <code>p: R =&gt; (R,A)</code>. Now, this looks a lot like an action in the <code>State</code> monad. But it&rsquo;s not. These <code>p</code> must satisfy the property that <code>_1</code> is their inverse. Which means that the <code>R</code> they return must be exactly the <code>R</code> they were given. So it&rsquo;s like a <code>State</code> action that is <em>read only</em>. We can therefore simplify this to the ordinary (non-dependent) type <code>R =&gt; A</code>. And now we have our <code>Reader</code> monad.</p>

<h2>Constructing the comonad</h2>

<p>But what about the other way around? What is the comonad constructed by composing <code>R*</code> with <code>Π_R</code>? Well, since we end up in the slice category, our comonad is actually in that category rather than in <em>Set</em>.</p>

<p>We start with an object <code>q: A =&gt; R</code> in the slice category. Then we go to types by doing <code>Π_R(q)</code>. This gives us a dependent type <code>P_A</code> which is inhabited by all <code>p: R =&gt; A</code> such that <code>q</code> is their inverse. Then we take <code>rStar[Π_R(q)]</code> to go back to the slice category and we find ourselves at an object <code>f: (R, Π_R(q)) =&gt; R</code>, which you&rsquo;ll recall is implemented as <code>_._1</code>. As an endofunctor in <em>Set/R</em>, <code>λq. rStar[Π_R(q)]</code> takes all <code>q: A =&gt; R</code> to <code>p: (R, R =&gt; A) =&gt; R = _._1</code> such that <code>p</code> is only defined on <code>R =&gt; A</code> arguments whose inverse is <code>q</code>.</p>

<p>That is, the counit for this comonad on elements <code>y: A =&gt; R</code> must be a function <code>counit: (R, Π_R(y)) =&gt; A</code> such that for <code>_._1: (R, Π_R(y)) =&gt; R</code>, the property <code>y compose counit = _._1</code> holds. Note that this means that the <code>R</code> returned by <code>_._1</code> and the <code>R</code> returned by <code>y</code> must be the same. Recall that <code>_._1</code> always returns the first element of its argument, and also recall that the functions in <code>Π_R(y)</code> must have <code>y</code> as their inverse, so they&rsquo;re only defined at the first element of the argument to <code>_._1</code>. That is <code>p._2(x)</code> is only defined when <code>x = p._1</code>.</p>

<p>If we try to encode that in Scala (ignoring all the &ldquo;such that&rdquo;), we get something like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">(</span><span class="kt">R</span><span class="o">,</span> <span class="kt">R</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">))</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">p</span><span class="o">.</span><span class="n">_2</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This looks a lot like a <code>counit</code> for the <code>Store</code> comonad! Except what we constructed is not that. Because of the additional requirements imposed by our functors and by the slice category, the second element of <code>p</code> can only take an argument that is exactly the first element of <code>p</code>. So we can simplify that to <code>(R, () =&gt; A)</code> or just <code>(R, A)</code>. And we now have the familiar <code>Coreader</code> comonad.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Scala Comonad Tutorial, Part 1]]></title>
    <link href="http://runarorama.github.com/blog/2015/06/23/a-scala-comonad-tutorial/"/>
    <updated>2015-06-23T01:15:47-04:00</updated>
    <id>http://runarorama.github.com/blog/2015/06/23/a-scala-comonad-tutorial</id>
    <content type="html"><![CDATA[<p>In chapter 11 of <a href="http://manning.com/bjarnason">our book</a>, we talk about monads in Scala. This finally names a pattern that the reader has seen throughout the book and gives it a formal structure. We also give some intuition for what it <em>means</em> for something to be a monad. Once you have this concept, you start recognizing it everywhere in the daily business of programming.</p>

<p>Today I want to talk about <em>comonads</em>, which are the dual of monads. The utility of comonads in everyday life is not quite as immediately obvious as that of monads, but they definitely come in handy sometimes. Particularly in applications like image processing and scientific computation.</p>

<h2>A monad, upside-down</h2>

<p>Let&rsquo;s remind ourselves of what a monad is. A monad is a functor, which just means it has a <code>map</code> method:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This has to satisfy the law that <code>map(x)(a =&gt; a) == x</code>, i.e. that mapping the identity function over our functor is a no-op.</p>

<h3>Monads</h3>

<p>A monad is a functor <code>M</code> equipped with two additional polymorphic functions; One from <code>A</code> to <code>M[A]</code> and one from <code>M[M[A]]</code> to <code>M[A]</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">mma</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Recall that <code>join</code> has to satisfy associativity, and <code>unit</code> has to be an identity for <code>join</code>.</p>

<p>In Scala a monad is often stated in terms of <code>flatMap</code>, which is <code>map</code> followed by <code>join</code>. But I find this formulation easier to explain.</p>

<p>Every monad has the above operations, the so-called <em>proper morphisms</em> of a monad, and may also bring to the table some <em>nonproper morphisms</em> which give the specific monad some additional capabilities.</p>

<h4>Reader monad</h4>

<p>For example, the <code>Reader</code> monad brings the ability to ask for a value:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Reader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">ask</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span><span class="k">:</span> <span class="kt">Reader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Reader</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The meaning of <code>join</code> in the reader monad is to pass the same context of type <code>R</code> to both the outer scope and the inner scope:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">Reader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">Reader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">]])</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">Reader</span><span class="o">((</span><span class="n">c</span><span class="k">:</span><span class="kt">R</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="o">).</span><span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Writer monad</h4>

<p>The <code>Writer</code> monad has the ability to write a value on the side:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Writer</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">log</span><span class="k">:</span> <span class="kt">W</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">tell</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">A</span><span class="o">](</span><span class="n">w</span><span class="k">:</span> <span class="kt">W</span><span class="o">)</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Writer</span><span class="o">((),</span> <span class="n">w</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The meaning of <code>join</code> in the writer monad is to concatenate the &ldquo;log&rdquo; of written values using the monoid for <code>W</code> (this is using the <code>Monoid</code> class from <a href="http://github.com/scalaz/scalaz">Scalaz</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">W:Monoid</span>,<span class="kt">A</span><span class="o">](</span><span class="n">w</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">Writer</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">A</span><span class="o">]])</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">Writer</span><span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="o">,</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">W</span><span class="o">].</span><span class="n">append</span><span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="n">log</span><span class="o">,</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">log</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the meaning of <code>unit</code> is to write the &ldquo;empty&rdquo; log:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">W:Monoid</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Writer</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">W</span><span class="o">].</span><span class="n">zero</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>State monad</h4>

<p>The <code>State</code> monad can both get and set the state:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span>
</span><span class='line'><span class="k">def</span> <span class="n">put</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">((),</span> <span class="n">s</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The meaning of <code>join</code> in the state monad is to give the outer action an opportunity to get and put the state, then do the same for the inner action, making sure any subsequent actions see the changes made by previous ones.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">S</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">v1</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">State</span><span class="o">(</span><span class="n">s1</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="o">(</span><span class="n">v2</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="k">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">v2</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">s2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">})</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Option monad</h4>

<p>The <code>Option</code> monad can terminate without an answer:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">none</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s enough examples of monads. Let&rsquo;s now turn to comonads.</p>

<h2>Comonads</h2>

<p>A comonad is the same thing as a monad, only backwards:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">W</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">W</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">w</span><span class="k">:</span> <span class="kt">W</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">wa</span><span class="k">:</span> <span class="kt">W</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">W</span><span class="o">[</span><span class="kt">W</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that counit is pronounced &ldquo;co-unit&rdquo;, not &ldquo;cow-knit&rdquo;. It&rsquo;s also sometimes called <code>extract</code> because it allows you to get a value of type <code>A</code> <em>out of</em> a <code>W[A]</code>. While with monads you can generally only put values in and not get them out, with comonads you can generally only get them out and not put them in.</p>

<p>And instead of being able to <code>join</code> two levels of a monad into one, we can <code>duplicate</code> one level of a comonad into two.</p>

<p>Kind of weird, right? This also has to obey some laws. We&rsquo;ll get to those later on, but let&rsquo;s first look at some actual comonads.</p>

<h3>The identity comonad</h3>

<p>A simple and obvious comonad is the dumb wrapper (the identity comonad):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Id</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">counit</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Id</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This one is also the identity <em>monad</em>. <code>Id</code> doesn&rsquo;t have any functionality other than the proper morphisms of the (co)monad and is therefore not terribly interesting. We can get the value out with our <code>counit</code>, and we can vacuously <code>duplicate</code> by decorating our existing <code>Id</code> with another layer.</p>

<h3>The reader comonad</h3>

<p>There&rsquo;s a comonad with the same capabilities as the reader monad, namely that it allows us to ask for a value:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">](</span><span class="n">extract</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ask</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coreader</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">extract</span><span class="o">),</span> <span class="n">ask</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Coreader</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ask</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>It should be obvious how we can give a <code>Comonad</code> instance for this (I&rsquo;m using the <a href="https://github.com/non/kind-projector">Kind Projector compiler plugin</a> to make the syntax look a little nicer than Vanilla Scala):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">coreaderComonad</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span><span class="k">:</span> <span class="kt">Comonad</span><span class="o">[</span><span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="n">c</span> <span class="n">map</span> <span class="n">f</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">extract</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">duplicate</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">duplicate</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Arguably, this is much more straightforward in Scala than the reader monad. In the reader <em>monad</em>, the <code>ask</code> function is the identity function. That&rsquo;s saying &ldquo;once the <code>R</code> value is available, return it to me&rdquo;, making it available to subsequent <code>map</code> and <code>flatMap</code> operations. But in <code>Coreader</code>, we don&rsquo;t have to pretend to have an <code>R</code> value. It&rsquo;s just right there and we can look at it.</p>

<p>So <code>Coreader</code> just wraps up some value of type <code>A</code> together with some additional context of type <code>R</code>. Why is it important that this is a <em>comonad</em>? What is the meaning of <code>duplicate</code> here?</p>

<p>To see the meaning of <code>duplicate</code>, notice that it puts the whole <code>Coreader</code> in the value slot (in the <code>extract</code> portion). So any subsequent <code>extract</code> or <code>map</code> operation will be able to observe both the value of type <code>A</code> and the context of type <code>R</code>. We can think of this as passing the context along to those subsequent operations, which is analogous to what the reader monad does.</p>

<p>In fact, just like <code>map</code> followed by <code>join</code> is usually expressed as <code>flatMap</code>, by the same token <code>duplicate</code> followed by <code>map</code> is usually expressed as a single operation, <code>extend</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">](</span><span class="n">extract</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ask</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">extend</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">duplicate</span> <span class="n">map</span> <span class="n">f</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that the type signature of <code>extend</code> looks like <code>flatMap</code> with the direction of <code>f</code> reversed. And just like we can chain operations in a monad using <code>flatMap</code>, we can chain operations in a comonad using <code>extend</code>. In <code>Coreader</code>, <code>extend</code> is making sure that <code>f</code> can use the context of type <code>R</code> to produce its <code>B</code>.</p>

<p>Chaining operations this way using <code>flatMap</code> in a monad is sometimes called <em>Kleisli composition</em>, and chaining operations using <code>extend</code> in a comonad is called <em>coKleisli</em> composition (or just Kleisli composition in a comonad).</p>

<p>The name <code>extend</code> refers to the fact that it takes a &ldquo;local&rdquo; computation that operates on some structure and &ldquo;extends&rdquo; that to a &ldquo;global&rdquo; computation that operates on all substructures of the larger structure.</p>

<h3>The writer comonad</h3>

<p>Just like the writer monad, the writer comonad can append to a log or running tally using a monoid. But instead of keeping the log always available to be appended to, it uses the same trick as the reader monad by building up an operation that gets executed once a log becomes available:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cowriter</span><span class="o">[</span><span class="kt">W:Monoid</span>,<span class="kt">A</span><span class="o">](</span><span class="n">tell</span><span class="k">:</span> <span class="kt">W</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cowriter</span><span class="o">(</span><span class="n">tell</span> <span class="n">andThen</span> <span class="n">f</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">extract</span> <span class="k">=</span> <span class="n">tell</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">W</span><span class="o">].</span><span class="n">zero</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="k">:</span> <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>, <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Cowriter</span><span class="o">(</span><span class="n">w1</span> <span class="k">=&gt;</span> <span class="nc">Cowriter</span><span class="o">(</span><span class="n">w2</span> <span class="k">=&gt;</span> <span class="n">tell</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">W</span><span class="o">].</span><span class="n">append</span><span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">))))</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">extend</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">duplicate</span> <span class="n">map</span> <span class="n">f</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that <code>duplicate</code> returns a whole <code>Cowriter</code> from its constructed <code>run</code> function, so the meaning is that subsequent operations (composed via <code>map</code> or <code>extend</code>) have access to exactly one <code>tell</code> function, which appends to the existing log or tally. For example, <code>foo.extend(_.tell("hi"))</code> will append <code>"hi"</code> to the log of <code>foo</code>.</p>

<h2>Comonad laws</h2>

<p>The comonad laws are analogous to the monad laws:</p>

<ol>
<li>Left identity: <code>wa.duplicate.extract == wa</code></li>
<li>Right identity: <code>wa.extend(extract) == wa</code></li>
<li>Associativity: <code>wa.duplicate.duplicate == wa.extend(duplicate)</code></li>
</ol>


<p>It can be hard to get an intuition for what these laws <em>mean</em>, but in short they mean that (co)Kleisli composition in a comonad should be associative and that <code>extract</code> (a.k.a. <code>counit</code>) should be an identity for it.</p>

<p>Very informally, both the monad and comonad laws mean that we should be able to compose our programs top-down or bottom-up, or any combination thereof, and have that mean the same thing regardless.</p>

<h2>Next time&hellip;</h2>

<p>In <a href="http://blog.higher-order.com/blog/2015/10/04/scala-comonad-tutorial-part-2/">part 2</a> we&rsquo;ll look at some more examples of comonads and follow some of the deeper connections. Like what&rsquo;s the relationship between the reader monad and the reader comonad, or the writer monad and the writer comonad? They&rsquo;re not identical, but they seem to do all the same things. Are they equivalent? Isomorphic? Something else?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Easy Performance Wins With Scalaz]]></title>
    <link href="http://runarorama.github.com/blog/2015/06/18/easy-performance-wins-with-scalaz/"/>
    <updated>2015-06-18T15:09:21-04:00</updated>
    <id>http://runarorama.github.com/blog/2015/06/18/easy-performance-wins-with-scalaz</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve found that if I&rsquo;m using <code>scala.concurrent.Future</code> in my code, I can get some really easy performance gains by just switching to <code>scalaz.concurrent.Task</code> instead, particularly if I&rsquo;m chaining them with <code>map</code> or <code>flatMap</code> calls, or with <code>for</code> comprehensions.</p>

<h2>Jumping into thread pools</h2>

<p>Every <code>Future</code> is basically some work that needs to be submitted to a thread pool. When you call <code>futureA.flatMap(a =&gt; futureB)</code>, both <code>Future[A]</code> and <code>Future[B]</code> need to be submitted to the thread pool, even though they are not running concurrently and could theoretically run on the same thread. This context switching takes a bit of time.</p>

<h2>Jumping on trampolines</h2>

<p>With <code>scalaz.concurrent.Task</code> you have a bit more control over when you submit work to a thread pool and when you actually want to continue on the thread that is already executing a <code>Task</code>. When you say <code>taskA.flatMap(a =&gt; taskB)</code>, the <code>taskB</code> will by default just continue running on the same thread that was already executing <code>taskA</code>. If you explicitly want to dip into the thread pool, you have to say so with <code>Task.fork</code>.</p>

<p>This works since a <code>Task</code> is not a concurrently running computation. It&rsquo;s a <em>description</em> of a computation—a sequential list of instructions that may include instructions to submit some of the work to thread pools. The work is actually executed by a tight loop in <code>Task</code>&rsquo;s <code>run</code> method. This loop is called a <em>trampoline</em> since every step in the <code>Task</code> (that is, every subtask) returns control to this loop.</p>

<p>Jumping on a trampoline is a lot faster than jumping into a thread pool, so whenever we&rsquo;re composing <code>Future</code>s with <code>map</code> and <code>flatMap</code>, we can just switch to <code>Task</code> and make our code faster.</p>

<h2>Making fewer jumps</h2>

<p>But sometimes we know that we want to continue on the same thread and we don&rsquo;t want to spend the time jumping on a trampoline at every step. To demonstrate this, I&rsquo;ll use the Ackermann function. This is not necessarily a good use case for <code>Future</code> but it shows the difference well.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Only defined for positive `m` and `n`</span>
</span><span class='line'><span class="k">def</span> <span class="n">ackermann</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ackermann</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ackermann</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">ackermann</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This function is supposed to terminate for all positive <code>m</code> and <code>n</code>, but if they are modestly large, this recursive definition overflows the stack. We could use futures to alleviate this, jumping into a thread pool instead of making a stack frame at each step:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">ackermannF</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">(</span><span class="n">ackermannF</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">Future</span><span class="o">(</span><span class="n">ackermannF</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'>      <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">x</span>
</span><span class='line'>      <span class="n">z</span> <span class="k">&lt;-</span> <span class="nc">Future</span><span class="o">(</span><span class="n">ackermannF</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
</span><span class='line'>      <span class="n">r</span> <span class="k">&lt;-</span> <span class="n">z</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">r</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Since there&rsquo;s no actual concurrency going on here, we can make this instantly faster by switching to <code>Task</code> instead, using a trampoline instead of a thread pool:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scalaz.concurrent.Task</span><span class="o">,</span> <span class="nc">Task</span><span class="o">.</span><span class="k">_</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">ackermannT</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">now</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">suspend</span><span class="o">(</span><span class="n">ackermannT</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="n">suspend</span><span class="o">(</span><span class="n">ackermannT</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)).</span><span class="n">flatMap</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="n">suspend</span><span class="o">(</span><span class="n">ackermannT</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But even here, we&rsquo;re making too many jumps back to the trampoline with <code>suspend</code>. We don&rsquo;t actually need to suspend and return control to the trampoline at each step. We only need to do it enough times to avoid overflowing the stack. Let&rsquo;s say we know how large our stack can grow:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">maxStack</span> <span class="k">=</span> <span class="mi">512</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can then keep track of how many recursive calls we&rsquo;ve made, and jump on the trampoline only when we need to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">ackermannO</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">stack</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">stack</span> <span class="o">&gt;=</span> <span class="n">maxStack</span><span class="o">)</span>
</span><span class='line'>      <span class="n">suspend</span><span class="o">(</span><span class="n">ackermannO</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span>
</span><span class='line'>    <span class="k">else</span> <span class="n">go</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">stack</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">go</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">stack</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">now</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">step</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">stack</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">internalRec</span> <span class="k">&lt;-</span> <span class="n">step</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">stack</span><span class="o">)</span>
</span><span class='line'>        <span class="n">result</span>      <span class="k">&lt;-</span> <span class="n">step</span><span class="o">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">internalRec</span><span class="o">,</span> <span class="n">stack</span><span class="o">)</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="n">go</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>How fast is it?</h2>

<p>I did some comparisons using <a href="https://github.com/google/caliper">Caliper</a> and made this pretty graph for you:</p>

<p><img src="http://runarorama.github.com/images/futuretaskplot.png"></p>

<p>The horizontal axis is the number of steps, and the vertical axis is the mean time that number of steps took over a few thousand runs.</p>

<p>This graph shows that <code>Task</code> is slightly faster than <code>Future</code> for submitting to thread pools (blue and yellow lines marked <em>Future</em> and <em>Task</em> respectively) only for very small tasks; up to about when you get to 50 steps, when (on my Macbook) both futures and tasks cross the 30 μs threshold. This difference is probably due to the fact that a <code>Future</code> is a running computation while a <code>Task</code> is partially constructed up front and explicitly <code>run</code> later. So with the <code>Future</code> the threads might just be waiting for more work. The overhead of <code>Task.run</code> seems to catch up with us at around 50 steps.</p>

<p>But honestly the difference between these two lines is not something I would care about in a real application, because if we jump on the trampoline instead of submitting to a thread pool (green line marked <em>Trampoline</em>), things are <em>between one and two orders of magnitude faster</em>.</p>

<p>If we only jump on the trampoline when we really need it (red line marked <em>Optimized</em>), we can gain another order of magnitude. Compared to the original naïve version that always goes to the thread pool, <strong><em>this is now the difference between running your program on a 10 MHz machine and running it on a 1 GHz machine</em></strong>.</p>

<p>If we measure without using any <code>Task</code>/<code>Future</code> at all, the line tracks the <em>Optimized</em> red line pretty closely then shoots to infinity around 1000 (or however many frames fit in your stack space) because the program crashes at that point.</p>

<p>In summary, if we&rsquo;re smart about trampolines vs thread pools, <code>Future</code> vs <code>Task</code>, and optimize for our stack size, we can go from milliseconds to microseconds with not very much effort. Or seconds to milliseconds, or weeks to hours, as the case may be.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pulling Out of Functional Programming in Java]]></title>
    <link href="http://runarorama.github.com/blog/2015/06/16/pulling-out-of-functional-programming-in-java/"/>
    <updated>2015-06-16T11:37:34-04:00</updated>
    <id>http://runarorama.github.com/blog/2015/06/16/pulling-out-of-functional-programming-in-java</id>
    <content type="html"><![CDATA[<p>After giving it a lot of thought I have come to the conclusion that I won&rsquo;t be involved in <a href="http://manning.com/saumont">“Functional Programming in Java”</a>. There are many reasons, including that I just don’t think I can spend the time to make this a good book. Looking at all the things I have scheduled for the rest of the year, I can’t find the time to work on it.</p>

<p>More depressingly, the thought of spending a year or more writing another book makes me anxious. I know from experience that making a book (at least a good one) is really hard and takes up a lot of mental energy. Maybe one day there will be a book that I will want to forego a year of evenings and weekends for, but today is not that day.</p>

<p>Originally, the content of FPiJ was going to be based on &ldquo;Functional Programming in Scala&rdquo;, but after some discussion with the publisher I think we were all beginning to see that this book deserved its own original content specifically on an FP style in Java.</p>

<p>I really do think such a thing deserves its own original book. Since Java is strictly less suitable for functional programming than Scala is, a book on FP in Java will have to lay a lot of groundwork that we didn&rsquo;t have to do with FPiS, and it will have to forego a lot of the more advanced topics.</p>

<p>I wish the author of that book, and the publisher, all the best and I hope they do well. I&rsquo;m sorry to let you all down, but I&rsquo;m sure this is for the best.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Companion Booklet to FPiS]]></title>
    <link href="http://runarorama.github.com/blog/2015/03/06/a-companion-booklet-to-functional-programming-in-scala/"/>
    <updated>2015-03-06T15:17:35-05:00</updated>
    <id>http://runarorama.github.com/blog/2015/03/06/a-companion-booklet-to-functional-programming-in-scala</id>
    <content type="html"><![CDATA[<p>Our book, <a href="http://manning.com/bjarnason">Functional Programming in Scala</a>, relies heavily on exercises. Hints and answers for those exercises are not actually in the book, but are <a href="http://github.com/fpinscala/fpinscala">freely available on GitHub</a> under a permissive MIT license. Likewise, we have written chapter notes that we reference throughout the book and made them <a href="http://github.com/fpinscala/fpinscala/wiki">available as a community-editable wiki</a>.</p>

<p>Naturally, readers get the most out of this book by downloading the source code from GitHub and doing the exercises as they read. But a number of readers have made the comment that they wish they could have the hints and answers with them when they read the book on the train to and from work, on a long flight, or wherever there is no internet connection or it&rsquo;s not convenient to use a computer.</p>

<p>It is of course entirely possible to print out the chapter notes, hints, and exercises, and take them with you either as a hardcopy or as a PDF to use on a phone or tablet. Well, I&rsquo;ve taken the liberty of doing that work for you. I wrote a little script to concatenate all the chapter notes, errata, hints, and answers into Markdown files and then just printed them all to a single document, tweaking a few things here and there. I&rsquo;m calling this <em>A companion booklet to &ldquo;Functional Programming in Scala&rdquo;</em>. It is released under the same <a href="https://github.com/fpinscala/fpinscala/blob/master/LICENSE">MIT license</a> as the content it aggregates. This means you&rsquo;re free to copy it, distribute or sell it, or basically do whatever you want with it. The Markdown source of the manuscript is <a href="https://github.com/runarorama/fpiscompanion">available on my GitHub</a>.</p>

<p>I have made <a href="https://leanpub.com/fpinscalacompanion">an electronic version of this booklet available on Leanpub</a> as as a PDF, ePub, and Kindle file on a pay-what-you-want basis (minimum of $0.99). It has full color syntax highlighting throughout and a few little tweaks to make it format nicely. The paper size is standard US Letter which makes it easy to print on most color printers. If you choose to buy the booklet from Leanpub, they get a small fee, a small portion of the proceeds goes to support <a href="http://www.libertyinnorthkorea.org/">Liberty in North Korea</a>, and the rest goes to yours truly. You&rsquo;ll also get updates when those inevitably happen.</p>

<p>If you don&rsquo;t care about any of that, <a href="http://runarorama.github.com/assets/fpiscompanion.pdf">you can grab the PDF from here with my compliments</a>.</p>

<p>The booklet is also <a href="https://www.createspace.com/5325404">available from CreateSpace</a> or <a href="http://www.amazon.com/companion-booklet-Functional-Programming-Scala/dp/1508537569">Amazon</a> as a full color printed paperback. This comes in a nicely bound glossy cover for just a little more than the price of printing (they print it on demand for you). I&rsquo;ve ordered one and I&rsquo;m really happy with the quality of this print:</p>

<p><img src="http://runarorama.github.com/images/bookletcover.jpg">
<img src="http://runarorama.github.com/images/chapternotes.jpg">
<img src="http://runarorama.github.com/images/exercises.jpg"></p>

<p>The print version is of course under the same permissive license, so you can make copies of it, make derivative works, or do whatever you want. It&rsquo;s important to note that with this booklet I&rsquo;ve not done anything other than design a little cover and then <em>literally print out this freely available content</em> and upload it to Amazon, which anybody could have done (and you still can if you want).</p>

<p>I hope this makes <em>Functional Programming in Scala</em> more useful and more enjoyable for more people.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Better Reading List With Mathematica]]></title>
    <link href="http://runarorama.github.com/blog/2015/02/08/a-better-reading-list-with-mathematica/"/>
    <updated>2015-02-08T11:04:00-05:00</updated>
    <id>http://runarorama.github.com/blog/2015/02/08/a-better-reading-list-with-mathematica</id>
    <content type="html"><![CDATA[<p>Like a lot of people, I keep a list of books I want to read. And because there are a great many more books that interest me than I can possibly read in my lifetime, this list has become quite long.</p>

<p>In the olden days of brick-and-mortar bookstores and libraries, I would discover books to read by browsing shelves and picking up what looked interesting at the time. I might even find something that I knew was on my list. &ldquo;Oh, I&rsquo;ve been meaning to read that!&rdquo;</p>

<p>The Internet changes this dynamic dramatically. It makes it much easier for me to discover books that interest me, and also to access any book that I might want to read, instantly, anywhere. At any given time, I have a couple of books that I&rsquo;m &ldquo;currently reading&rdquo;, and when I finish one I can start another immediately. I use Goodreads to manage my to-read list, and it&rsquo;s easy for me to scroll through the list and pick out my next book.</p>

<p>But again, this list is very long. So I wanted a good way to filter out books I will really never read, and sort it such that the most &ldquo;important&rdquo; books in some sense show up first. Then every time I need a new book I could take the first one from the list and make a binary decision: either &ldquo;I will read this right now&rdquo;, or &ldquo;I am never reading this&rdquo;. In the latter case, if a book interests me enough at a later time, I&rsquo;m sure it will find its way back onto my list.</p>

<p>The problem then is to find a good metric by which to rank books. Goodreads lets users rank books with a star-rating from 1 to 5, and presents you with an average rating by which you can sort the list. The problem is that a lot of books that interest me have only one rating and it&rsquo;s 5 stars, giving the book an &ldquo;average&rdquo; of 5.0. So if I go with that method I will be perpetually reading obscure books that one other person has read and loved. This is not necessarily a bad thing, but I do want to branch out a bit.</p>

<p>Another possibility is to use the number of ratings to calculate a <a href="http://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval">confidence interval</a> for the average rating. For example, using the <a href="http://www.evanmiller.org/how-not-to-sort-by-average-rating.html">Wilson score</a> I could find an upper and lower bound <code>s1</code> and <code>s2</code> (higher and lower than the average rating, respectively) that will let me say &ldquo;I am 95% sure that any random sample of readers of an equal size would give an average rating between <code>s1</code> and <code>s2</code>.&rdquo; I could then sort the list by the lower bound <code>s1</code>.</p>

<p>But this method is dissatisfactory for a number of reasons. First, it&rsquo;s not clear how to fit star ratings to such a measure. If we do the naive thing and count a 1-star rating as 1/5 and a 5 star rating as 5/5, that counts a 1-star rating as a &ldquo;partial success&rdquo; in some sense. We could discard 1-stars as 0, and count 2, 3, 4, and 5 stars as 25%, 50%, 75%, and 100%, respectively.</p>

<p>But even if we did make it fit somehow, it turns out that if you take <em>any moderately popular book</em> on Goodreads at random, it will have an average rating somewhere close to 4. I could <a href="http://stephsun.com/silverizing.html">manufacture a prior</a> based on this knowledge and use that instead of the normal distribution or the Jeffreys prior in the confidence interval, but that would still not be a very good ranking because <a href="http://stephsun.com/metascores.html">reader review metascores are meaningless</a>.</p>

<p>In the article <a href="http://stephsun.com/metascores.html">&ldquo;Reader review metascores are meaningless&rdquo;</a>, Stephanie Shun suggests using the <em>percentage of 5-star ratings</em> as the relevant metric rather than the average rating. This is a good suggestion, since even a single 5-star rating carries a lot of actionable information whereas an average rating close to 4.0 carries very little.</p>

<p>I can then use the Wilson score directly, counting a 5-star rating as a successful trial and any other rating as a failed one. I can then just use the normal distribution instead of working with an artisanally curated prior.</p>

<p>Mathematica makes it easy to generate the Wilson score. Here, <code>pos</code> is the number of positive trials (number of 5-star ratings), <code>n</code> is the number of total ratings, and <code>confidence</code> is the desired confidence percentage. I&rsquo;m taking the lower bound of the confidence interval to get my score.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">Wilson</span><span class="p">[</span><span class="nv">pos_</span><span class="p">,</span><span class="w"> </span><span class="nv">n_</span><span class="p">,</span><span class="w"> </span><span class="nv">confidence_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span>
</span><span class='line'><span class="w">  </span><span class="n">If</span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="err">&lt;</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
</span><span class='line'><span class="w">    </span><span class="n">With</span><span class="p">[{</span><span class="w"></span>
</span><span class='line'><span class="w">      </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Quantile</span><span class="p">[</span><span class="n">NormalDistribution</span><span class="p">[],</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">confidence</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span>
</span><span class='line'><span class="w">      </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pos</span><span class="o">/</span><span class="n">n</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="p">},</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">z</span><span class="w"> </span><span class="n">Sqrt</span><span class="p">[(</span><span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"></span>
</span><span class='line'><span class="w">      </span><span class="p">(</span><span class="n">z</span><span class="o">^</span><span class="mi">2</span><span class="o">/</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="p">]</span><span class="w"></span>
</span><span class='line'><span class="w">  </span><span class="p">]</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>Now I just need to get the book data from Goodreads. Fortunately, <a href="https://www.goodreads.com/api">it has a pretty rich API</a>. I just need a developer key, which anyone can get for free.</p>

<p>For example, to get the ratings for a given book <code>id</code>, we can use their XML api for books and pattern match on the result to get the ratings by score:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">Ratings</span><span class="p">[</span><span class="nv">id_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">Ratings</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
</span><span class='line'><span class="w">  </span><span class="n">With</span><span class="p">[{</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="n">raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cases</span><span class="p">[</span><span class="n">Import</span><span class="p">[</span><span class="n">ToString</span><span class="p">[</span><span class="n">StringForm</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">        </span><span class="s">&quot;http://www.goodreads.com/book/show.xml?key=``&amp;id=``&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">]]],</span><span class="w"></span>
</span><span class='line'><span class="w">      </span><span class="n">XMLElement</span><span class="p">[</span><span class="s">&quot;rating_dist&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nv">d_</span><span class="p">}]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">Infinity</span><span class="p">]</span><span class="w"></span>
</span><span class='line'><span class="w">  </span><span class="p">},</span><span class="w"> </span>
</span><span class='line'><span class="w">  </span><span class="n">With</span><span class="p">[{</span><span class="w"></span>
</span><span class='line'><span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StringSplit</span><span class="p">[</span><span class="nv">#</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">StringSplit</span><span class="p">[</span><span class="n">raw</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|&quot;</span><span class="p">]</span><span class="w"></span>
</span><span class='line'><span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="n">Block</span><span class="p">[{},</span><span class="w"> </span><span class="n">Pause</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
</span><span class='line'><span class="w">  </span><span class="n">FromDigits</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">Association</span><span class="p">[</span><span class="n">Rule</span><span class="w"> </span><span class="o">@@@</span><span class="w"> </span><span class="n">First</span><span class="p">[</span><span class="n">data</span><span class="p">]]]]];</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>Here, <code>key</code> is my Goodreads developer API key, defined elsewhere. I put a <code>Pause[1]</code> in the call since Goodreads throttles API calls so you can&rsquo;t make more than one call per second to each API endpoint. I&rsquo;m also memoizing the result, by assigning to <code>Ratings[id]</code> in the global environment.</p>

<p><code>Ratings</code> will give us an association list with the number of ratings for each score from 1 to 5, together with the total. For example, for the first book in their catalogue, <em>Harry Potter and the Half-Blood Prince</em>, here are the scores:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">:=</span><span class="w"> </span><span class="n">Ratings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"></span>
</span><span class='line'>
</span><span class='line'><span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="w"> </span><span class="err">&lt;</span><span class="o">|</span><span class="s">&quot;5&quot;</span><span class="w">     </span><span class="o">-&gt;</span><span class="w">  </span><span class="mi">782740</span><span class="p">,</span><span class="w"></span>
</span><span class='line'><span class="w">          </span><span class="s">&quot;4&quot;</span><span class="w">     </span><span class="o">-&gt;</span><span class="w">  </span><span class="mi">352725</span><span class="p">,</span><span class="w"></span>
</span><span class='line'><span class="w">          </span><span class="s">&quot;3&quot;</span><span class="w">     </span><span class="o">-&gt;</span><span class="w">  </span><span class="mi">111068</span><span class="p">,</span><span class="w"></span>
</span><span class='line'><span class="w">          </span><span class="s">&quot;2&quot;</span><span class="w">     </span><span class="o">-&gt;</span><span class="w">   </span><span class="mi">17693</span><span class="p">,</span><span class="w"></span>
</span><span class='line'><span class="w">          </span><span class="s">&quot;1&quot;</span><span class="w">     </span><span class="o">-&gt;</span><span class="w">    </span><span class="mi">5289</span><span class="p">,</span><span class="w"></span>
</span><span class='line'><span class="w">          </span><span class="s">&quot;total&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1269515</span><span class="o">|</span><span class="err">&gt;</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>Sweet. Let&rsquo;s see how Harry Potter #6 would score with our rating:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">In</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">:=</span><span class="w"> </span><span class="n">Wilson</span><span class="p">[</span><span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s">&quot;5&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">Out</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s">&quot;total&quot;</span><span class="p">],</span><span class="w"> </span><span class="mf">0.95</span><span class="p">]</span><span class="w"></span>
</span><span class='line'>
</span><span class='line'><span class="n">Out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="w"> </span><span class="mf">0.61572</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>So Wilson is 95% confident that in any random sample of about 1.2 million Harry Potter readers, at least 61.572% of them would give <em>The Half-Blood Prince</em> a 5-star rating. That turns out to be a pretty high score, so if this book were on my list (which it isn&rsquo;t), it would feature pretty close to the very top.</p>

<p>But now the score for a relatively obscure title is too low. For example, the lower bound of the 95% confidence interval for a single-rating 5-star book will be 0.206549, which will be towards the bottom of any list. This means I would never get to any of the obscure books on my reading list, since they would be edged out by moderately popular books with an average rating close to 4.0.</p>

<p>See, if I&rsquo;ve picked a book that <em>I want to read</em>, I&rsquo;d consider five ratings that are all five stars a much stronger signal than the fact that people who like Harry Potter enough to read 5 previous books loved the 6th one. Currently the 5*5 book will score 57%, a bit weaker than the Potter book&rsquo;s 62%.</p>

<p>I can fix this by lowering the confidence level. Because honestly, I don&rsquo;t need a high confidence in the ranking. I&rsquo;d rather err on the side of picking up a deservedly obscure book than to miss out on a rare gem. Experimenting with this a bit, I find that a confidence around 80% raises the obscure books enough to give me an interesting mix. For example, a 5*5 book gets a 75% rank, while the Harry Potter one stays at 62%.</p>

<p>I&rsquo;m going to call that the <em>Rúnar rank</em> of a given book. The Rúnar rank is defined as the lower bound of the <em>1-1/q</em> Wilson confidence interval for scoring in the <em>q</em>th <em>q</em>-quantile. In the special case of Goodreads ratings, it&rsquo;s the 80% confidence for a 5-star rating.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">RunarRank</span><span class="p">[</span><span class="nv">id_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">With</span><span class="p">[{</span><span class="n">ratings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ratings</span><span class="p">[</span><span class="n">id</span><span class="p">]},</span><span class="w"></span>
</span><span class='line'><span class="w">  </span><span class="n">Wilson</span><span class="p">[</span><span class="n">ratings</span><span class="p">[</span><span class="s">&quot;5&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">ratings</span><span class="p">[</span><span class="s">&quot;total&quot;</span><span class="p">],</span><span class="w"> </span><span class="mf">.8</span><span class="p">]]]</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>Unfortunately, there&rsquo;s no way to get the rank of all the books in my reading list in one call to the Goodreads API. And when I asked them about it they basically said &ldquo;you can&rsquo;t do that&rdquo;, so I&rsquo;m assuming that feature will not be added any time soon. So I&rsquo;ll have to get the reading list first, then call <code>RunarRank</code> for each book&rsquo;s <code>id</code>. In Goodreads, books are managed by &ldquo;shelves&rdquo;, and the API allows getting the contents of a given shelf, 200 books at a time:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">GetShelf</span><span class="p">[</span><span class="nv">user_</span><span class="p">,</span><span class="w"> </span><span class="nv">shelf_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
</span><span class='line'><span class="w">  </span><span class="n">With</span><span class="p">[{</span><span class="n">raw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
</span><span class='line'><span class="w">    </span><span class="n">Cases</span><span class="p">[</span><span class="n">Import</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">      </span><span class="n">ToString</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">       </span><span class="n">StringForm</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">        </span><span class="err">&quot;</span><span class="n">http</span><span class="err">:</span><span class="o">//</span><span class="n">www</span><span class="err">.</span><span class="n">goodreads</span><span class="err">.</span><span class="n">com</span><span class="o">/</span><span class="n">review</span><span class="o">/</span><span class="n">list</span><span class="err">.</span><span class="n">xml</span><span class="o">?</span><span class="n">v</span><span class="o">=</span><span class="mi">2</span><span class="o">&amp;</span><span class="n">key</span><span class="o">=</span><span class="err">``</span><span class="o">&amp;</span><span class="n">id</span><span class="o">=</span><span class="err">``</span><span class="o">&amp;</span><span class="err">\</span><span class="w"></span>
</span><span class='line'><span class="n">shelf</span><span class="o">=</span><span class="err">``</span><span class="o">&amp;</span><span class="n">sort</span><span class="o">=</span><span class="nv">avg_rating</span><span class="o">&amp;</span><span class="n">order</span><span class="o">=</span><span class="n">d</span><span class="o">&amp;</span><span class="nv">per_page</span><span class="o">=</span><span class="mi">200</span><span class="err">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p">,</span><span class="w"> </span><span class="n">shelf</span><span class="p">]]],</span><span class="w"> </span>
</span><span class='line'><span class="w">     </span><span class="n">XMLElement</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">       </span><span class="s">&quot;book&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nv">___</span><span class="p">,</span><span class="w"> </span><span class="n">XMLElement</span><span class="p">[</span><span class="s">&quot;id&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">___</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nv">id_</span><span class="p">}],</span><span class="w"> </span><span class="nv">___</span><span class="p">,</span><span class="w"> </span>
</span><span class='line'><span class="w">        </span><span class="n">XMLElement</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nv">title_</span><span class="p">}],</span><span class="w"> </span><span class="nv">___</span><span class="p">,</span><span class="w"> </span>
</span><span class='line'><span class="w">        </span><span class="n">XMLElement</span><span class="p">[</span><span class="s">&quot;average_rating&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nv">avg_</span><span class="p">}],</span><span class="w"> </span><span class="nv">___</span><span class="p">,</span><span class="w"> </span>
</span><span class='line'><span class="w">        </span><span class="n">XMLElement</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">         </span><span class="s">&quot;authors&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">XMLElement</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">           </span><span class="s">&quot;author&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nv">___</span><span class="p">,</span><span class="w"> </span>
</span><span class='line'><span class="w">            </span><span class="n">XMLElement</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">             </span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="nv">author_</span><span class="p">}],</span><span class="w"> </span><span class="nv">___</span><span class="p">}],</span><span class="w"> </span><span class="nv">___</span><span class="p">}],</span><span class="w"> </span><span class="nv">___</span><span class="p">}]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;id&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span>
</span><span class='line'><span class="w">        </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;title&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;author&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">author</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;avg&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">avg</span><span class="p">},</span><span class="w"> </span>
</span><span class='line'><span class="w">     </span><span class="n">Infinity</span><span class="p">]},</span><span class="w"> </span><span class="n">Association</span><span class="w"> </span><span class="o">/@</span><span class="w"> </span><span class="n">raw</span><span class="p">]</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;m doing a bunch of XML pattern matching here to get the <code>id</code>, <code>title</code>, <code>average_rating</code>, and first <code>author</code> of each book. Then I put that in an association list. I&rsquo;m getting only the top-200 books on the list by average rating (which currently is about half my list).</p>

<p>With that in hand, I can get the contents of my &ldquo;to-read&rdquo; shelf with <code>GetShelf[runar, "to-read"]</code>, where <code>runar</code> is my Goodreads user id. And given that, I can call <code>RunarRank</code> on each book on the shelf, then sort the result by that rank:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">RunarSort</span><span class="p">[</span><span class="nv">shelf_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
</span><span class='line'><span class="w"> </span><span class="n">Sort</span><span class="p">[</span><span class="n">Map</span><span class="p">[</span><span class="n">Function</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">Append</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;rank&quot;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">RunarRank</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s">&quot;id&quot;</span><span class="p">]]]],</span><span class="w"> </span>
</span><span class='line'><span class="w">   </span><span class="n">shelf</span><span class="p">],</span><span class="w"> </span><span class="nv">#1</span><span class="p">[</span><span class="s">&quot;rank&quot;</span><span class="p">]</span><span class="w"> </span><span class="err">&gt;</span><span class="w"> </span><span class="nv">#2</span><span class="p">[</span><span class="s">&quot;rank&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="p">]</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>To get the ranked reading list of any user:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">ReadingList</span><span class="p">[</span><span class="nv">user_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">RunarSort</span><span class="p">[</span><span class="n">GetShelf</span><span class="p">[</span><span class="n">user</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;to-read&quot;</span><span class="p">]]</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>And to print it out nicely:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">Gridify</span><span class="p">[</span><span class="nv">books_</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span>
</span><span class='line'><span class="w"> </span><span class="n">Grid</span><span class="p">[</span><span class="n">Flatten</span><span class="p">[</span><span class="w"></span>
</span><span class='line'><span class="w">   </span><span class="n">Cases</span><span class="p">[</span><span class="n">books</span><span class="p">,</span><span class="w"> </span>
</span><span class='line'><span class="w">    </span><span class="nv">b_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
</span><span class='line'><span class="w">      </span><span class="p">{</span><span class="n">b</span><span class="p">[</span><span class="s">&quot;id&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="s">&quot;title&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">UnitConvert</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="s">&quot;rank&quot;</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;Percent&quot;</span><span class="p">]},</span><span class="w"></span>
</span><span class='line'><span class="w">      </span><span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="s">&quot;author&quot;</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="s">&quot;avg&quot;</span><span class="p">]},</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">}</span><span class="w"> </span><span class="p">}],</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"></span>
</span><span class='line'><span class="w">   </span><span class="n">Alignment</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Left</span><span class="p">]</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<p>Now I can get, say, the first 10 books on my improved reading list:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='mathematica'><span class='line'><span class="n">Gridify</span><span class="p">[</span><span class="n">ReadingList</span><span class="p">[</span><span class="n">runar</span><span class="p">][[</span><span class="mi">1</span><span class="w"> </span><span class="o">;;</span><span class="w"> </span><span class="mi">10</span><span class="p">]]]</span><span class="w"></span>
</span></code></pre></td></tr></table></div></figure>


<table>
<thead>
<tr>
<th style="text-align:left;"> </th>
<th style="text-align:left;"> </th>
<th style="text-align:right;"> </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 9934419 </td>
<td style="text-align:left;"> Kvæðasafn </td>
<td style="text-align:right;"> 75.2743% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Snorri Hjartarson </td>
<td style="text-align:right;"> 5.00 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 17278 </td>
<td style="text-align:left;"> The Feynman Lectures on Physics Vol 1 </td>
<td style="text-align:right;"> 67.2231% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Richard P. Feynman </td>
<td style="text-align:right;"> 4.58 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 640909 </td>
<td style="text-align:left;"> The Knowing Animal: A Philosophical Inquiry Into Knowledge and Truth </td>
<td style="text-align:right;"> 64.6221% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Raymond Tallis </td>
<td style="text-align:right;"> 5.00 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 640913 </td>
<td style="text-align:left;"> The Hand: A Philosophical Inquiry Into Human Being </td>
<td style="text-align:right;"> 64.6221% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Raymond Tallis </td>
<td style="text-align:right;"> 5.00 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 4050770 </td>
<td style="text-align:left;"> Volition As Cognitive Self Regulation </td>
<td style="text-align:right;"> 62.231% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Harry Binswanger </td>
<td style="text-align:right;"> 4.86 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 8664353 </td>
<td style="text-align:left;"> Unbroken: A World War II Story of Survival, Resilience, and Redemption </td>
<td style="text-align:right;"> 60.9849% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Laura Hillenbrand </td>
<td style="text-align:right;"> 4.45 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 13413455 </td>
<td style="text-align:left;"> Software Foundations </td>
<td style="text-align:right;"> 60.1596% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Benjamin C. Pierce </td>
<td style="text-align:right;"> 4.80 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 77523 </td>
<td style="text-align:left;"> Harry Potter and the Sorcerer&rsquo;s Stone (Harry Potter #1) </td>
<td style="text-align:right;"> 59.1459% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> J.K. Rowling </td>
<td style="text-align:right;"> 4.39 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 13539024 </td>
<td style="text-align:left;"> Free Market Revolution: How Ayn Rand&rsquo;s Ideas Can End Big Government </td>
<td style="text-align:right;"> 59.1102% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Yaron Brook </td>
<td style="text-align:right;"> 4.48 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;"> 1609224 </td>
<td style="text-align:left;"> The Law </td>
<td style="text-align:right;"> 58.767% </td>
</tr>
<tr>
<td style="text-align:left;">  </td>
<td style="text-align:left;"> Frédéric Bastiat </td>
<td style="text-align:right;"> 4.40 </td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


<p>I&rsquo;m quite happy with that. Some very popular and well-loved books interspersed with obscure ones with exclusively (or almost exclusively) positive reviews. The most satisfying thing is that the rating carries a real meaning. It&rsquo;s basically the relative likelihood that I will enjoy the book enough to rate it five stars.</p>

<p>I can test this ranking against books I&rsquo;ve already read. Here&rsquo;s the top of my &ldquo;read&rdquo; shelf, according to their Rúnar Rank:</p>

<table>
<thead>
<tr>
<th style="text-align:left;">    </th>
<th style="text-align:left;">    </th>
<th style="text-align:right;">    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">17930467</td>
<td style="text-align:left;">The Fourth Phase of Water</td>
<td style="text-align:right;">68.0406%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Gerald H. Pollack</td>
<td style="text-align:right;">4.85</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">7687279</td>
<td style="text-align:left;">Nothing Less Than Victory: Decisive Wars and the Lessons of History</td>
<td style="text-align:right;">64.9297%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">John David Lewis</td>
<td style="text-align:right;">4.67</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">43713</td>
<td style="text-align:left;">Structure and Interpretation of Computer Programs</td>
<td style="text-align:right;">62.0211%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Harold Abelson</td>
<td style="text-align:right;">4.47</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">7543507</td>
<td style="text-align:left;">Capitalism Unbound: The Incontestable Moral Case for Individual Rights</td>
<td style="text-align:right;">57.6085%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Andrew Bernstein</td>
<td style="text-align:right;">4.67</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">13542387</td>
<td style="text-align:left;">The DIM Hypothesis: Why the Lights of the West Are Going Out</td>
<td style="text-align:right;">55.3296%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Leonard Peikoff</td>
<td style="text-align:right;">4.37</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">5932</td>
<td style="text-align:left;">Twenty Love Poems and a Song of Despair</td>
<td style="text-align:right;">54.7205%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Pablo Neruda</td>
<td style="text-align:right;">4.36</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">18007564</td>
<td style="text-align:left;">The Martian</td>
<td style="text-align:right;">53.9136%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Andy Weir</td>
<td style="text-align:right;">4.36</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">24113</td>
<td style="text-align:left;">Gödel, Escher, Bach: An Eternal Golden Braid</td>
<td style="text-align:right;">53.5588%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Douglas R. Hofstadter</td>
<td style="text-align:right;">4.29</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">19312</td>
<td style="text-align:left;">The Brothers Lionheart</td>
<td style="text-align:right;">53.0952%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Astrid Lindgren</td>
<td style="text-align:right;">4.33</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left;">13541678</td>
<td style="text-align:left;">Functional Programming in Scala</td>
<td style="text-align:right;">52.6902%</td>
</tr>
<tr>
<td style="text-align:left;"></td>
<td style="text-align:left;">Rúnar Bjarnason</td>
<td style="text-align:right;">4.54</td>
</tr>
<tr>
<td style="text-align:left;">&nbsp;</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>


<p>That&rsquo;s perfect. Those are definitely books I thouroughly enjoyed and would heartily recommend. Especially that last one.</p>

<p>I&rsquo;ve published this function as a Wolfram Cloud API, and you can call it at <a href="https://www.wolframcloud.com/app/objects/4f4a7b3c-38a5-4bf3-81b6-7ca8e05ea100">https://www.wolframcloud.com/app/objects/4f4a7b3c-38a5-4bf3-81b6-7ca8e05ea100</a>. It takes two URL query parameters, <code>key</code> and <code>user</code>, which are your Goodreads API key and the Goodreads user ID whose reading list you want to generate, respectively. Enjoy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximally Powerful, Minimally Useful]]></title>
    <link href="http://runarorama.github.com/blog/2014/12/21/maximally-powerful/"/>
    <updated>2014-12-21T23:23:00-05:00</updated>
    <id>http://runarorama.github.com/blog/2014/12/21/maximally-powerful</id>
    <content type="html"><![CDATA[<p>It&rsquo;s well known that there is a trade-off in language and systems design between expressiveness and analyzability. That is, the more expressive a language or system is, the less we can reason about it, and vice versa. The more capable the system, the less comprehensible it is.</p>

<p>This principle is very widely applicable, and it&rsquo;s a useful thing to keep in mind when designing languages and libraries. A practical implication of being aware of this principle is that we always make components exactly as expressive as necessary, but no more. This maximizes the ability of any downstream systems to reason about our components. And dually, for things that we receive or consume, we should require exactly as much analytic power as necessary, and no more. That maximizes the expressive freedom of the upstream components.</p>

<p>I find myself thinking about this principle a lot lately, and seeing it more or less everywhere I look. So I&rsquo;m seeking a more general statement of it, if such a thing is possible. It seems that more generally than issues of expressivity/analyzability, a restriction at one semantic level translates to freedom and power at another semantic level.</p>

<p>What I want to do here is give a whole bunch of examples. Then we&rsquo;ll see if we can come up with an integration for them all. This is all written as an exercise in thinking out loud and is not to be taken very seriously.</p>

<h2>Examples from computer science</h2>

<h3>Context-free and regular grammars</h3>

<p>In formal language theory, context-free grammars are more expressive than regular grammars. The former can describe strictly more sets of strings than the latter. On the other hand, it&rsquo;s harder to reason about context-free grammars than regular ones. For example, we can decide whether two regular expressions are equal (they describe the same set of strings), but this is undecidable in general for context-free grammars.</p>

<h3>Monads and applicative functors</h3>

<p>If we know that an applicative functor is a monad, we gain some expressive power that we don&rsquo;t get with just an applicative functor. Namely, a monad is an applicative functor with an additional capability: monadic join (or &ldquo;bind&rdquo;, or &ldquo;flatMap&rdquo;). That is, context-sensitivity, or the ability to bind variables in monadic expressions.</p>

<p>This power comes at a cost. Whereas we can always compose any two applicatives to form a composite applicative, two monads do not in general compose to form a monad. It may be the case that a given monad composes with any other monad, but we need some additional information about it in order to be able to conclude that it does.</p>

<h3>Actors and futures</h3>

<p>Futures have an algebraic theory, so we can reason about them algebraically. Namely, they form an applicative functor which means that two futures <code>x</code> and <code>y</code> make a composite future that does <code>x</code> and <code>y</code> in parallel. They also compose sequentially since they form a monad.</p>

<p>Actors on the other hand have no algebraic theory and afford no algebraic reasoning of this sort. They are &ldquo;fire and forget&rdquo;, so they could potentially do anything at all. This means that actor systems can do strictly more things in more ways than systems composed of futures, but our ability to reason about such systems is drastically diminished.</p>

<h3>Typed and untyped programming</h3>

<p>When we have an untyped function, it could receive any type of argument and produce any type of output. The implementation is totally unrestricted, so that gives us a great deal of expressive freedom. Such a function can potentially participate in a lot of different expressions that use the function in different ways.</p>

<p>A function of type <code>Bool -&gt; Bool</code> however is highly restricted. Its argument can only be one of two things, and the result can only be one of two things as well. So there are 4 different implementations such a function could possibly have. Therefore this restriction gives us a great deal of analyzability.</p>

<p>For example, since the argument is of type <code>Bool</code> and not <code>Any</code>, the implementation mostly writes itself. We need to consider only two possibilities. <code>Bool</code> (a type of size 2) is fundamentally easier to reason about than <code>Any</code> (a type of potentially infinite size). Similarly, any usage of the function is easy to reason about. A caller can be sure not to call it with arguments other than <code>True</code> or <code>False</code>, and enlist the help of a type system to guarantee that expressions involving the function are meaningful.</p>

<h3>Total functional programming</h3>

<p>Programming in non-total languages affords us the power of general recursion and &ldquo;fast and loose reasoning&rdquo; where we can transition between valid states through potentially invalid ones. The cost is, of course, the halting problem. But more than that, we can no longer be certain that our programs are <em>meaningful</em>, and we lose some algebraic reasoning. For example, consider the following:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>map (- n) (map (+ n) xs)) == xs</span></code></pre></td></tr></table></div></figure>


<p>This states that adding <code>n</code> to every number in a list and then subtracting <code>n</code> again should be the identity. But what if <code>n</code> actually throws an exception or never halts? In a non-total language, we need some additional information. Namely, we need to know that <code>n</code> is total.</p>

<h3>Referential transparency and side effects</h3>

<p>The example above also serves to illustrate the trade-off between purely functional and impure programming. If <code>n</code> could have arbitrary side effects, algebraic reasoning of this sort involving <code>n</code> is totally annihilated. But if we know that <code>n</code> is referentially transparent, algebraic reasoning is preserved. The power of side effects comes at the cost of algebraic reasoning. This price includes loss of compositionality, modularity, parallelizability, and parametricity. Our programs can do strictly more things, but we can conclude strictly fewer things about our programs.</p>

<h2>Example from infosec</h2>

<p>There is a principle in computer security called <em>The Principle of Least Privilege</em>. It says that a user or program should have exactly as much authority as necessary but no more. This constrains the power of the entity, but greatly enhances the power of others to predict and reason about what the entity is going to do, resulting in the following benefits:</p>

<ul>
<li><strong>Compositionality</strong> &ndash; The fewer privileges a component requires, the easier it is to deploy inside a larger environment. For the purposes of safety, higher privileges are a barrier to composition since a composite system requires the <em>highest</em> privileges of any of its components.</li>
<li><strong>Modularity</strong> &ndash; A component with restricted privileges is easier to reason about in the sense that its interaction with other components will be limited. We can reason mechanically about where this limit actually is, which gives us better guarantees about the the security and stability of the overall system. A restricted component is also easier to test in isolation, since it can be run inside an overall restricted environment.</li>
</ul>


<h2>Example from politics</h2>

<p>Some might notice an analogy between the Principle of Least Privilege and the idea of a constitutionally limited government. An absolute dictatorship or pure democracy will have absolute power to enact whatever whim strikes the ruler or majority at the moment. But the overall stability, security, and freedom of the people is greatly enhanced by the presence of legal limits on the power of the government. A limited constitutional republic also makes for a better neighbor to other states.</p>

<p>More generally, a ban on the initiation of physical force by one citizen against another, or by the government against citizens, or against other states, makes for a peaceful and prosperous society. The &ldquo;cost&rdquo; of such a system is the inability of one person (or even a great number of people) to impose their preferences on others by force.</p>

<h2>An example from mathematics</h2>

<p>The framework of two-dimensional Euclidean geometry is simply an empty page on which we can construct lines and curves using tools like a compass and straightedge. When we go from that framework to a Cartesian one, we constrain ourselves to reasoning on a grid of pairs of numbers. This is a tradeoff between expressivity and analyzability. When we move fom Euclidean to Cartesian geometry, we lose the ability to assume isotropy of space, intersection of curves, and compatibility between dimensions. But we gain much more powerful things through the restriction: the ability to precisely define geometric objects, to do arithmetic with them, to generalize to higher dimensions, and to reason with higher abstractions like linear algebra and category theory.</p>

<h2>Examples from everyday life</h2>

<h3>Driving on roads</h3>

<p>Roads constrain the routes we can take when we drive or walk. We give up moving in a straight line to wherever we want to go. But the benefit is huge. Roads let us get to where we&rsquo;re going much faster and more safely than we would otherwise.</p>

<h3>Commodity components</h3>

<p>Let&rsquo;s say you make a decision to have only one kind of outfit that you wear on a daily basis. You just go out and buy multiple identical outfits. Whereas you have lost the ability to express yourself by the things you wear, you have gained a certain ability to reason about your clothing. The system is also fault-tolerant and compositional!</p>

<h2>Summary</h2>

<p>What is this principle? Here are some ways of saying it:</p>

<ul>
<li>Things that are maximally general for first-order applications are minimally useful for higher-order applications, and vice versa.</li>
<li>A language that is maximally expressive is minimally analyzable.</li>
<li>A simplifying assumption at one semantic level paves the way to a richer structure at a higher semantic level.</li>
</ul>


<p>What do you think? Can you think of a way to integrate these examples into a general principle? Do you have other favorite examples of this principle in action? Is this something everyone already knows about and I&rsquo;m just late to the party?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taking a Break From Twitter]]></title>
    <link href="http://runarorama.github.com/blog/2014/10/29/taking-a-break-from-twitter/"/>
    <updated>2014-10-29T13:23:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2014/10/29/taking-a-break-from-twitter</id>
    <content type="html"><![CDATA[<p>Today I disabled my Twitter account. Probably only temporarily, but we&rsquo;ll see. This is just a quick note to let everyone know that I&rsquo;m not leaving Twitter because of anything specific. It&rsquo;s not that you said or did anything wrong. I just find that it&rsquo;s becoming an energy sink for me. I&rsquo;m putting Twitter away as a measure to control my focus, and to better control what information I consume and produce.</p>

<p>Hopefully this means that I will post more here when I have something interesting to share. If you need to reach me, I&rsquo;m available by email. My address is <code>runar</code> at this blog&rsquo;s domain.</p>

<p>(UPDATE 2014-12-21): I&rsquo;ve recreated my Twitter account, but I&rsquo;m now using the service in a different way. The biggest change is that I don&rsquo;t follow anyone. It&rsquo;s strictly a broadcasting device for me, and not an information consumption device.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[At Long Last]]></title>
    <link href="http://runarorama.github.com/blog/2014/09/18/at-long-last/"/>
    <updated>2014-09-18T13:09:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2014/09/18/at-long-last</id>
    <content type="html"><![CDATA[<p>In early September 2014, we published <em>Functional Programming in Scala</em>. It is now available from all major booksellers, and from the publisher at <a href="http://manning.com/bjarnason/">manning.com/bjarnason</a>. It&rsquo;s available as a beautiful paper book, on Kindle and other e-book readers, and as a PDF file.</p>

<p>I just want to share my personal story of how this book came to exist. A much shorter version of this story became the preface for the finished book, but here is the long version.</p>

<p>Around 2006 I was working in Austin and coming up on my 8th anniversary as an enterprise Java programmer. I had started to notice that I was making a lot of the same mistakes over and over again. I had a copy of the Gang of Four’s Design Patterns on my desk that I referred to frequently, and I built what I thought were elegant object-oriented designs. Every new project started out well enough, but became a big ball of mud after a while. My once-elegant class hierarchies gathered bugs, technical debt, and unimplemented features. Making changes started to feel like trudging through a swamp. I was never confident that I wasn’t introducing defects as I went. My code was difficult to test or reuse, and impossible to reason about. My productivity plummeted, and a complete rewrite became inevitable. It was a vicious cycle.</p>

<p>In looking for a more disciplined approach, I came across Haskell and functional programming. Here was a community of people with a sound methodology for reasoning about their programs. In other words, they actually knew what they were doing. I found a lot of good ideas and proceeded to import them to Java. A little later I met Tony Morris, who had been doing the same, on IRC. He told me about this new JVM language, Scala. Tony had a library called Scalaz (scala-zed) that made FP in Scala more pleasant, and I started contributing to that library. One of the other people contributing to Scalaz was Paul Chiusano, who was working for a company in Boston. In 2008 he invited me to come work with him, doing Scala full time. I sold my house and everything in it, and moved to Boston.</p>

<p>Paul co-organized the Boston Area Scala Enthusiasts, a group that met monthly at Google’s office in Cambridge. It was a popular group, mainly among Java programmers who were looking for something better. But there was a clear gap between those who had come to Scala from an FP perspective and those who saw Scala as just a better way to write Java. In April 2010 another of the co-organizers, Nermin Serifovic, said he thought there was “tremendous demand” for a book that would bridge that gap, on the topic of functional programming in Scala. He suggested that Paul and I write that book. We had a very clear idea of the kind of book we wanted to write, and we thought it would be quick and easy. More than four years later, I think we have made a good book.</p>

<p>Paul and I hope to convey in this book some of the excitement that we felt when we were first discovering FP. It’s encouraging and empowering to finally feel like we’re writing comprehensible software that we can reuse and confidently build upon. We want to invite you to the world of programming as it could be and ought to be.</p>

<p>– Rúnar Óli Bjarnason</p>

<p>Boston, August 2014</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monoid Morphisms, Products, and Coproducts]]></title>
    <link href="http://runarorama.github.com/blog/2014/03/19/monoid-morphisms-products-coproducts/"/>
    <updated>2014-03-19T00:00:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2014/03/19/monoid-morphisms-products-coproducts</id>
    <content type="html"><![CDATA[<p>Today I want to talk about relationships between monoids. These can be useful to think about when we&rsquo;re developing libraries involving monoids, and we want to express some algebraic laws among them. We can then check these with automated tests, or indeed <em>prove</em> them with algebraic reasoning.</p>

<p>This post kind of fell together when writing notes on chapter 10, &ldquo;Monoids&rdquo;, of <a href="http://manning.com/bjarnason">Functional Programming in Scala</a>. I am putting it here so I can reference it from the chapter notes at the end of the book.</p>

<h2>Monoid homomorphisms</h2>

<p>Let&rsquo;s take the <code>String</code> concatenation and <code>Int</code> addition as example monoids that have a relationship. Note that if we take the length of two strings and add them up, this is the same as concatenating those two strings and taking the length of the combined string:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">).</span><span class="n">length</span>
</span></code></pre></td></tr></table></div></figure>


<p>So every <code>String</code> maps to a corresponding <code>Int</code> (its length), and every concatenation of strings maps to the addition of corresponding lengths.</p>

<p>The <code>length</code> function maps from <code>String</code> to <code>Int</code> <em>while preserving the monoid structure</em>. Such a function, that maps from one monoid to another in such a preserving way, is called a <em>monoid homomorphism</em>. In general, for monoids <code>M</code> and <code>N</code>, a homomorphism <code>f: M =&gt; N</code>, and all values <code>x:M</code>, <code>y:M</code>, the following equations hold:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">f</span><span class="o">(</span><span class="n">x</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">f</span><span class="o">(</span><span class="n">y</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">M</span><span class="o">])</span> <span class="o">==</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">N</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>|+|</code> syntax is from <a href="http://github.com/scalaz/scalaz">Scalaz</a> and is obtained by importing <code>scalaz.syntax.monoid._</code>. It just references the <code>append</code> method on the <code>Monoid[T]</code> instance, where <code>T</code> is the type of the arguments. The <code>mzero[T]</code> function is also from that same import and references <code>zero</code> in <code>Monoid[T]</code>.</p>

<p>This <em>homomorphism law</em> can have real practical benefits. Imagine for example a &ldquo;result set&rdquo; monoid that tracks the locations of a particular set of records in a database or file. This could be as simple as a <code>Set</code> of locations. Concatenating several thousand files and then proceeding to search through them is going to be much slower than searching through the files individually and then concatenating the result sets. Particularly since we can potentially search the files in parallel. A good automated test for our result set monoid would be that it admits a homomorphism from the data file monoid.</p>

<h2>Monoid isomorphisms</h2>

<p>Sometimes there will be a homomorphism in both directions between two monoids. If these are inverses of one another, then this kind of relationship is called a <em>monoid isomorphism</em> and we say that the two monoids are isomorphic. More precisely, we will have two monoids <code>A</code> and <code>B</code>, and homomorphisms <code>f: A =&gt; B</code> and <code>g: B =&gt; A</code>. If <code>f(g(b)) == b</code> and <code>g(f(a)) == a</code>, for all <code>a:A</code> and <code>b:B</code> then <code>f</code> and <code>g</code> form an isomorphism.</p>

<p>For example, the <code>String</code> and <code>List[Char]</code> monoids with concatenation are isomorphic. We can convert a <code>String</code> to a <code>List[Char]</code>, preserving the monoid structure, and go back again to the exact same <code>String</code> we started with. This is also true in the inverse direction, so the isomorphism holds.</p>

<p>Other examples include (<code>Boolean</code>, <code>&amp;&amp;</code>) and (<code>Boolean</code>, <code>||</code>) which are isomorphic via <code>not</code>.</p>

<p>Note that there are monoids with homomorphisms in both directions between them that nevertheless are <em>not</em> isomorphic. For example, (<code>Int</code>, <code>*</code>) and (<code>Int</code>, <code>+</code>). These are homomorphic to one another, but not isomorphic (thanks, Robbie Gates).</p>

<h2>Monoid products and coproducts</h2>

<p>If <code>A</code> and <code>B</code> are monoids, then <code>(A,B)</code> is certainly a monoid, called their <em>product</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">product</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">),</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="k">=</span>
</span><span class='line'>      <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">_1</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_2</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">zero</span> <span class="k">=</span> <span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But is there such a thing as a monoid <em>coproduct</em>? Could we just use <code>Either[A,B]</code> for monoids <code>A</code> and <code>B</code>? What would be the <code>zero</code> of such a monoid? And what would be the value of <code>Left(a) |+| Right(b)</code>? We could certainly choose an arbitrary rule, and we may even be able to satisfy the monoid laws, but would that mean we have a <em>monoid coproduct</em>?</p>

<p>To answer this, we need to know the precise meaning of <em>product</em> and <em>coproduct</em>. These come straight from Wikipedia, with a little help from Cale Gibbard.</p>

<p>A <em>product</em> <code>M</code> of two monoids <code>A</code> and <code>B</code> is a monoid such that there exist homomorphisms <code>fst: M =&gt; A</code>, <code>snd: M =&gt; B</code>, and for any monoid <code>Z</code> and morphisms <code>f: Z =&gt; A</code> and <code>g: Z =&gt; B</code> there has to be a unique homomorphism <code>h: Z =&gt; M</code> such that <code>fst(h(z)) == f(z)</code> and <code>snd(h(z)) == g(z)</code> for all <code>z:Z</code>. In other words, the following diagram must commute:</p>

<p><img src="http://runarorama.github.com/images/Product.png"></p>

<p>A <em>coproduct</em> <code>W</code> of two monoids <code>A</code> and <code>B</code> is the same except the arrows are reversed. It&rsquo;s a monoid such that there exist homomorphisms <code>left: A =&gt; W</code>, <code>right: B =&gt; W</code>, and for any monoid <code>Z</code> and morphisms <code>f: A =&gt; Z</code> and <code>g: B =&gt; Z</code> there has to be a unique homomorphism <code>h: W =&gt; Z</code> such that <code>h(left(a)) == f(a)</code> and <code>h(right(b)) == g(b)</code> for all <code>a:A</code> and all <code>b:B</code>. In other words, the following diagram must commute:</p>

<p><img src="http://runarorama.github.com/images/Coproduct.png"></p>

<p>We can easily show that our <code>productMonoid</code> above really is a monoid product. The homomorphisms are the methods <code>_1</code> and <code>_2</code> on <code>Tuple2</code>. They simply map every element of <code>(A,B)</code> to a corresponding element in <code>A</code> and <code>B</code>. The monoid structure is preserved because:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">p</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">).</span><span class="n">_1</span> <span class="o">==</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_1</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'><span class="o">(</span><span class="n">p</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">).</span><span class="n">_2</span> <span class="o">==</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_2</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">zero</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)].</span><span class="n">_1</span> <span class="o">==</span> <span class="n">zero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="n">zero</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)].</span><span class="n">_2</span> <span class="o">==</span> <span class="n">zero</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And for any other monoid <code>Z</code>, and morphisms <code>f: Z =&gt; A</code> and <code>g: Z =&gt; B</code>, we can construct a unique morphism from <code>Z</code> to <code>(A,B)</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">factor</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">Z</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">z</span><span class="o">),</span> <span class="n">g</span><span class="o">(</span><span class="n">z</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And this really is a homomorphism because we just inherit the homomorphism law from <code>f</code> and <code>g</code>.</p>

<p>What does a coproduct then look like? Well, it&rsquo;s going to be a type <code>C[A,B]</code> together with an instance <code>coproduct[A:Monoid,B:Monoid]:Monoid[C[A,B]]</code>. It will be equipped with two monoid homomorphisms, <code>left: A =&gt; C[A,B]</code> and <code>right: B =&gt; C[A,B]</code> that satisfy the following (according to the monoid homomorphism law):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">a1</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">left</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span> <span class="o">==</span> <span class="n">left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span>
</span><span class='line'><span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">b1</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">right</span><span class="o">(</span><span class="n">b2</span><span class="o">))</span> <span class="o">==</span> <span class="n">right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">left</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">==</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]</span>
</span><span class='line'><span class="n">right</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="o">==</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And additionally, for any other monoid <code>Z</code> and homomorphisms <code>f: A =&gt; Z</code> and <code>g: B =&gt; Z</code> we must be able to construct a unique homomorphism from <code>C[A,B]</code> to <code>Z</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
</span></code></pre></td></tr></table></div></figure>


<p>Right off the bat, we know some things that <em>definitely won&rsquo;t work</em>. Just using <code>Either</code> is a non-starter because there&rsquo;s no well-defined <code>zero</code> for it, and there&rsquo;s no way of appending a <code>Left</code> to a <code>Right</code>. But what if we just added that structure?</p>

<h3>Free monoids on coproducts</h3>

<p>The underlying set of a monoid <code>A</code> is just the type <code>A</code> without the monoid structure. The coproduct of types <code>A</code> and <code>B</code> is the type <code>Either[A,B]</code>. Having &ldquo;forgotten&rdquo; the monoid structure of both <code>A</code> and <code>B</code>, we can recover it by generating a free monoid on <code>Either[A,B]</code>, which is just <code>List[Either[A,B]]</code>. The <code>append</code> operation of this monoid is list concatenation, and the identity for it is the empty list.</p>

<p>Clearly <code>List[Either[A,B]]</code> is a monoid, but does it permit a homomorphism from both monoids <code>A</code> and <code>B</code>? If so, then the following properties should hold:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">))</span>
</span><span class='line'><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">))</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>They clearly do not hold! The lists on the left of <code>==</code> will have two elements and the lists on the right will have one element. Can we do something about this?</p>

<p>Well, the fact is that <code>List[Either[A,B]]</code> is not exactly the monoid coproduct of <code>A</code> and <code>B</code>. It&rsquo;s still &ldquo;too big&rdquo;. The problem is that we can observe the internal structure of expressions.</p>

<p>What we need is not exactly the <code>List</code> monoid, but a new monoid called the <em>free monoid product</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">class</span> <span class="nc">Eithers</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span>
</span><span class='line'>  <span class="k">private</span> <span class="k">val</span> <span class="n">toList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]])</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="o">++(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>      <span class="nc">Eithers</span><span class="o">(</span><span class="n">toList</span> <span class="o">++</span> <span class="n">p</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z:Monoid</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
</span><span class='line'>      <span class="n">toList</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">Z</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">z</span>
</span><span class='line'>        <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">z</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">Eithers</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">left</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">right</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">]</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="k">new</span> <span class="nc">Eithers</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]())</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">),</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>    <span class="o">})</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Eithers[A,B]</code> is a kind of <code>List[Either[A,B]]</code> that has been normalized so that consecutive <code>A</code>s and consecutive <code>B</code>s have been collapsed using their respective monoids. So it will contain alternating <code>A</code> and <code>B</code> values.</p>

<p>The only remaining problem is that a list full of identities is not exactly the same as the empty list. Remember the unit part of the homomorphism law:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">mzero</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">Eithers</span><span class="o">.</span><span class="n">empty</span>
</span><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">mzero</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">Eithers</span><span class="o">.</span><span class="n">empty</span>
</span></code></pre></td></tr></table></div></figure>


<p>This doesn&rsquo;t hold at the moment. As Cale Gibbard points out in the comments below, <code>Eithers</code> is really the free monoid on the coproduct of <em>semigroups</em> <code>A</code> and <code>B</code>.</p>

<p>We could check each element as part of the normalization step to see if it <code>equals(zero)</code> for the given monoid. But that&rsquo;s a problem, as there are lots of monoids for which we can&rsquo;t write an <code>equals</code> method. For example, for the <code>Int =&gt; Int</code> monoid (with composition), we must make use of a notion like extensional equality, which we can&rsquo;t reasonably write in Scala.</p>

<p>So what we have to do is sort of wave our hands and say that equality on <code>Eithers[A,B]</code> is defined as whatever notion of equality we have for <code>A</code> and <code>B</code> respectively, with the rule that <code>es.fold[(A,B)]</code> defines the equality of <code>Eithers[A,B]</code>. For example, for monoids that really can have <code>Equal</code> instances:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">eithersEqual</span><span class="o">[</span><span class="kt">A:Monoid:Equal</span>,<span class="kt">B:Monoid:Equal</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">le</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">ri</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">z</span><span class="o">(</span><span class="n">es</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>        <span class="n">es</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">le</span><span class="o">,</span> <span class="n">ri</span><span class="o">)(</span><span class="nc">Monoid</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)])</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">z</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span> <span class="o">===</span> <span class="n">z</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we have to settle with a list full of zeroes being &ldquo;morally equivalent&rdquo; to an empty list. The difference is observable in e.g. the time it takes to traverse the list.</p>

<p>Setting that issue aside, <code>Eithers</code> is a monoid coproduct because it permits monoid homomorphisms from <code>A</code> and <code>B</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">)))</span> <span class="o">++</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">))))</span> <span class="o">==</span>
</span><span class='line'>  <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)))</span>
</span><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">)))</span> <span class="o">++</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">))))</span> <span class="o">==</span>
</span><span class='line'>  <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And <code>fold</code> really is a homomorphism, and we can prove it by case analysis. Here&rsquo;s the law again:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">e1</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">g</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">e2</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">g</span><span class="o">))</span> <span class="o">==</span> <span class="o">(</span><span class="n">e1</span> <span class="o">++</span> <span class="n">e2</span><span class="o">).</span><span class="n">fold</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">g</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If either of <code>e1</code> or <code>e2</code> is empty then the result is the fold of the other, so those cases are trivial. If they are both nonempty, then they will have one of these forms:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">e1</span> <span class="k">=</span> <span class="o">[</span><span class="kt">...</span>, <span class="kt">Left</span><span class="o">(</span><span class="kt">a1</span><span class="o">)]</span>
</span><span class='line'><span class="n">e2</span> <span class="k">=</span> <span class="o">[</span><span class="kt">Left</span><span class="o">(</span><span class="kt">a2</span><span class="o">)</span>, <span class="kt">...</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">e1</span> <span class="k">=</span> <span class="o">[</span><span class="kt">...</span>, <span class="kt">Right</span><span class="o">(</span><span class="kt">b1</span><span class="o">)]</span>
</span><span class='line'><span class="n">e2</span> <span class="k">=</span> <span class="o">[</span><span class="kt">Right</span><span class="o">(</span><span class="kt">b2</span><span class="o">)</span>, <span class="kt">...</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">e1</span> <span class="k">=</span> <span class="o">[</span><span class="kt">...</span>, <span class="kt">Left</span><span class="o">(</span><span class="kt">a</span><span class="o">)]</span>
</span><span class='line'><span class="n">e2</span> <span class="k">=</span> <span class="o">[</span><span class="kt">Right</span><span class="o">(</span><span class="kt">b</span><span class="o">)</span>, <span class="kt">...</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">e1</span> <span class="k">=</span> <span class="o">[</span><span class="kt">...</span>, <span class="kt">Right</span><span class="o">(</span><span class="kt">b</span><span class="o">)]</span>
</span><span class='line'><span class="n">e2</span> <span class="k">=</span> <span class="o">[</span><span class="kt">Left</span><span class="o">(</span><span class="kt">a</span><span class="o">)</span>, <span class="kt">...</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the first two cases, on the right of the <code>==</code> sign in the law, we perform <code>a1 |+| a2</code> and <code>b1 |+| b2</code> respectively before concatenating. In the other two cases we simply concatenate the lists. The <code>++</code> method on <code>Eithers</code> takes care of doing this correctly for us. On the left of the <code>==</code> sign we fold the lists individually and they will be alternating applications of <code>f</code> and <code>g</code>. So then this law amounts to the fact that <code>f(a1 |+| a2) == f(a1) |+| f(a2)</code> in the first case, and the same for <code>g</code> in the second case. In the latter two cases this amounts to a homomorphism on <code>List</code>. So as long as <code>f</code> and <code>g</code> are homomorphisms, so is <code>_.fold(f,g)</code>. Therefore, <code>Eithers[A,B]</code> is a coproduct of <code>A</code> and <code>B</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Free Monads and the Yoneda Lemma]]></title>
    <link href="http://runarorama.github.com/blog/2013/11/01/free-and-yoneda/"/>
    <updated>2013-11-01T00:00:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2013/11/01/free-and-yoneda</id>
    <content type="html"><![CDATA[<p>Last week I gave a talk on <em>Purely Functional I/O</em> at Scala.io in Paris. <a href="http://blog.higher-order.com/assets/scalaio.pdf">The slides for the talk are available here.</a> In it I presented a data type for <code>IO</code> that is supposedly a &ldquo;free monad&rdquo;. But the monad I presented is not exactly the same as <code>scalaz.Free</code> and some people have been asking me why there is a difference and what that difference means.</p>

<h2>IO as an application of Free</h2>

<p>The <code>Free</code> monad in Scalaz is given a bit like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Suspend</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And throughout the methods on <code>Free</code>, it is required that <code>F</code> is a <em>functor</em> because in order to get at the recursive step inside a <code>Suspend</code>, we need to <code>map</code> over the <code>F</code> somehow.</p>

<p>But the <code>IO</code> monad I gave in the talk looks more like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Req</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">I</span>,<span class="kt">A</span><span class="o">](</span><span class="n">req</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">],</span> <span class="n">k</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And it could actually be stated as an application of <code>Free</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">type</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Free</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>, <span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">α</span><span class="o">)</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">I</span><span class="o">}})</span><span class="k">#</span><span class="kt">λ</span>, <span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>So in a very superficial sense, this is how the <code>IO</code> monad relates to <code>Free</code>. The monad <code>IO[F,_]</code> for a given <code>F</code> is the free monad generated by the functor <code>(F[I], I =&gt; _)</code> for some type <code>I</code>. And do note that <em>this is a functor no matter what <code>F</code> is</em>.</p>

<h2>IO as equivalent to Free</h2>

<p>There is a deeper sense in which <code>IO</code> and <code>Free</code> are actually equivalent (more precisely, isomorphic). That is, there exists a transformation from one to the other and back again. Since the only difference between <code>IO</code> and <code>Free</code> is in the functors <code>F[_]</code> vs <code>∃I. (F[I], I =&gt; _)</code>, we just have to show that these two are isomorphic for any <code>F</code>.</p>

<h3>The Yoneda lemma</h3>

<p>There is an important result in category theory known as the <em>Yoneda lemma</em>. What it says is that if you have a function defined like this&hellip;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>&hellip;then you certainly have a value of type <code>F[A]</code>. All you need is to pass the identity function to <code>map</code> in order to get the value of type <code>F[A]</code> out of this function. In fact, a function like this is in practice probably defined as a method on a value of type <code>F[A]</code> anyway. This also means that <code>F</code> is definitely a functor.</p>

<p>The Yoneda lemma says that this goes the other way around as well. If you have a value of type <code>F[A]</code> for any functor <code>F</code> and any type <code>A</code>, then you certainly have a <code>map</code> function with the signature above.</p>

<p>In scala terms, we can capture this in a type:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Yoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the Yoneda lemma says that there is an isomorphism between <code>Yoneda[F,A]</code> and <code>F[A]</code>, for any functor <code>F</code> and any type <code>A</code>. Here is the proof:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scalaz._</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">toYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Yoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">froYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">yo</span><span class="k">:</span> <span class="kt">Yoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">yo</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>CoYoneda</h3>

<p>Of course, this also means that if we have a type <code>B</code>, a function of type <code>(B =&gt; A)</code> for some type <code>A</code>, and a value of type <code>F[B]</code> for some functor <code>F</code>, then we certainly have a value of type <code>F[A]</code>. This is kind of obvious, since we can just pass the <code>B =&gt; A</code> and the <code>F[B]</code> to the <code>map</code> function for the functor and get our <code>F[A]</code>.</p>

<p>But the opposite is also true, and that is the really interesting part. If we have a value of type <code>F[A]</code>, for any <code>F</code> and <code>A</code>, then we can always destructure it into a value of type <code>F[B]</code> and a function of type <code>B =&gt; A</code>, at least for <em>some</em> type <code>B</code>. And it turns out that we can do this even if <code>F</code> is not a functor.</p>

<p>This is the permutation of the Yoneda lemma that we were using in <code>IO</code> above. That is, <code>IO[F, A]</code> is really <code>Free[({type λ[α] = CoYoneda[F,α]})#λ, A]</code>, given:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">CoYoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">I</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">f</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the lemma says that <code>CoYoneda[F,A]</code> is isomorphic to <code>F[A]</code>. Here is the proof:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">toCoYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CoYoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">fi</span> <span class="k">=</span> <span class="n">fa</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">def</span> <span class="n">froCoYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">A</span><span class="o">](</span><span class="n">yo</span><span class="k">:</span> <span class="kt">CoYo</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">yo</span><span class="o">.</span><span class="n">fi</span><span class="o">)(</span><span class="n">yo</span><span class="o">.</span><span class="n">f</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Of course, this destructuring into <code>CoYoneda</code> using the identity function is the simplest and most general, but there may be others for specific <code>F</code> and <code>A</code> depending on what we know about them.</p>

<p>So there you have it. The <code>scalaz.Free</code> monad with its <code>Suspend(F[Free[F,A]])</code> constructor and the <code>IO</code> monad with its <code>Req(F[I], I =&gt; IO[F,A])</code> constructor are actually equivalent. The latter is simply making use of <code>CoYoneda</code> to say the same thing.</p>

<p>Why bother? The useful part is that <code>CoYoneda[F,_]</code> is a functor for any <code>F</code>, so it&rsquo;s handy to use in a free monad since we can then drop the requirement that <code>F</code> is a functor. What&rsquo;s more, it gives us <em>map fusion</em> for free, since <code>map</code> over <code>CoYoneda</code> is literally just function composition on its <code>f</code> component. Although this latter is, in the absence of tail call elimination, not as useful as it could be in Scala.</p>

<p>I hope that sheds a little bit of light on the Yoneda lemma as well as the different embeddings of free monads.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Free Monoids and Free Monads]]></title>
    <link href="http://runarorama.github.com/blog/2013/08/20/free-monads-and-free-monoids/"/>
    <updated>2013-08-20T00:00:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2013/08/20/free-monads-and-free-monoids</id>
    <content type="html"><![CDATA[<p>In a series of old posts, I once talked about the link between <a href="http://apocalisp.wordpress.com/2010/06/14/on-monoids/">lists and monoids</a>, as well as <a href="http://apocalisp.wordpress.com/2010/07/21/more-on-monoids-and-monads/">monoids and monads</a>. Now I want to talk a little bit more about monoids and monads from the perspective of <em>free structures</em>.</p>

<p><code>List</code> is a <em>free monoid</em>. That is, for any given type <code>A</code>, <code>List[A]</code> is a monoid, with list concatenation as the operation and the empty list as the identity element.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">freeMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span> <span class="k">=</span> <span class="nc">Nil</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">op</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">a1</span> <span class="o">++</span> <span class="n">a2</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Being a free monoid means that it&rsquo;s the <em>minimal</em> such structure. <code>List[A]</code> has exactly enough structure so that it is a monoid for any given <code>A</code>, and it has no further structure. This also means that for any given monoid <code>B</code>, there must exist a transformation, a <em>monoid homomorphism</em> from <code>List[A]</code> to <code>B</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>Given a mapping from <code>A</code> to a monoid <code>B</code>, we can collapse a value in the monoid <code>List[A]</code> to a value in <code>B</code>.</p>

<h2>Free monads</h2>

<p>Now, if you followed my old posts, you already know that monads are &ldquo;higher-kinded monoids&rdquo;. A monoid in a category where the objects are type constructors (functors, actually) and the arrows between them are natural transformations. As a reminder, a natural transformation from <code>F</code> to <code>G</code> can be represented this way in Scala:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">~&gt;</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And it turns out that there is a free monad for any given functor <code>F</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Suspend</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Analogous to how a <code>List[A]</code> is either <code>Nil</code> (the empty list) or a product of a <code>head</code> element and <code>tail</code> list, a value of type <code>Free[F,A]</code> is either an <code>A</code> or a product of <code>F[_]</code> and <code>Free[F,_]</code>. It is a recursive structure. And indeed, it has <em>exactly enough structure</em> to be a monad, for any given <code>F</code>, and no more.</p>

<p>When I say &ldquo;product&rdquo; of two functors like <code>F[_]</code> and <code>Free[F,_]</code>, I mean a product like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">:*:</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we might expect that there is a <em>monad homomorphism</em> from a free monad on <code>F</code> to any monad that <code>F</code> can be transformed to. And indeed, it turns out that there is. The free monad catamorphism is in fact a monad homomorphism. Given a natural transformation from <code>F</code> to <code>G</code>, we can collapse a <code>Free[F,A]</code> to <code>G[A]</code>, just like with <code>foldMap</code> when given a function from <code>A</code> to <code>B</code> we could collapse a <code>List[A]</code> to <code>B</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">runFree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Monad</span>,<span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>But what&rsquo;s the equivalent of <code>foldRight</code> for <code>Free</code>? Remember, foldRight takes a unit element <code>z</code> and a function that accumulates into <code>B</code> so that <code>B</code> doesn&rsquo;t actually have to be a monoid. Here, <code>f</code> is a lot like the monoid operation, except it takes the current <code>A</code> on the left:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldRight</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>The equivalent for <code>Free</code> takes a natural transformation as its unit element, which for a monad happens to be monadic <code>unit</code>. Then it takes a natural transformation as its <code>f</code> argument, that looks a lot like monadic <code>join</code>, except it takes the current <code>F</code> on the left:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">type</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">foldFree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span>
</span><span class='line'>  <span class="n">as</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])(</span>
</span><span class='line'>  <span class="n">z</span><span class="k">:</span> <span class="kt">Id</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)(</span>
</span><span class='line'>  <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">F:*:G</span><span class="o">)</span><span class="k">#</span><span class="kt">λ</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this case, <code>G</code> does not have to be a monad at all.</p>

<p><code>Free</code> as well as natural transformations and product types are available in <a href="http://github.com/scalaz">Scalaz</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machines and Stream Processing]]></title>
    <link href="http://runarorama.github.com/blog/2013/01/26/machines/"/>
    <updated>2013-01-26T12:34:00-05:00</updated>
    <id>http://runarorama.github.com/blog/2013/01/26/machines</id>
    <content type="html"><![CDATA[<p>I gave a talk on &ldquo;Machines&rdquo; and stream processing in <a href="https://github.com/ekmett/machines">Haskell</a> and <a href="https://github.com/runarorama/scala-machines">Scala</a>, to the <a href="http://www.bfpg.org/">Brisbane Functional Programming Group</a> at Microsoft HQ in December 2012. A lot of people have asked me for the slides, so here they are:</p>

<p><a href="https://dl.dropbox.com/u/4588997/Machines.pdf">Machines.pdf</a></p>

<p>The preëmptive answer to the usual follow-up question is that the talk was not recorded.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Purity Is and Isn't]]></title>
    <link href="http://runarorama.github.com/blog/2012/09/13/what-purity-is-and-isnt/"/>
    <updated>2012-09-13T22:07:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2012/09/13/what-purity-is-and-isnt</id>
    <content type="html"><![CDATA[<p>A lot of discussion about &ldquo;purity&rdquo; goes on without participants necessarily having a clear idea of what it means exactly. Such discussion is generally unhelpful and distracting.</p>

<h3>What purity is</h3>

<p>The typical definition of purity (and the one we use in <a href="http://manning.com/bjarnason">our book</a>) goes something like this:</p>

<p>An expression <code>e</code> is <em>referentially transparent</em> if for all programs <code>p</code>, every occurrence of <code>e</code> in <code>p</code> can be replaced with the result of evaluating <code>e</code> without changing the result of evaluating <code>p</code>.</p>

<p>A function <code>f</code> is <em>pure</em> if the expression <code>f(x)</code> is referentially transparent for all referentially transparent <code>x</code>.</p>

<p>Now, something needs to be made clear right up front. Like all definitions, this holds in a specific <em>context</em>. In particular, the context needs to specify what &ldquo;evaluating&rdquo; means. It also needs to define &ldquo;program&rdquo;, &ldquo;occurrence&rdquo;, and the semantics of &ldquo;replacing&rdquo; one thing with another.</p>

<p>In a programming language like Haskell, Java, or Scala, this context is pretty well established. The process of evaluation is a reduction to some <em>normal form</em> such as weak head or beta normal form.</p>

<h3>A simple example</h3>

<p>To illustrate, let&rsquo;s consider programs in an exceedingly simple language that we will call <em>Sigma</em>. An expression in Sigma has one of the following forms:</p>

<ul>
<li>A literal character string like <code>"a"</code>, <code>"foo"</code>, <code>""</code>, etc.</li>
<li>A concatenation, <code>s + t</code>, for expressions <code>s</code> and <code>t</code>.</li>
<li>A special <code>Ext</code> expression that denotes input from an external source.</li>
</ul>


<p>Now, without an evaluator for Sigma, it is a purely abstract algebra. So let&rsquo;s define a straigtforward evaluator <code>eval</code> for it, with the following rules:</p>

<ul>
<li>A literal string is already in normal form.</li>
<li><code>eval(s + t)</code> first evaluates <code>s</code> and <code>t</code> and concatenates the results into one literal string.</li>
<li><code>eval(Ext)</code> reads a line from standard input and returns it as a literal string.</li>
</ul>


<p>This might seem very simple, but it is still not clear whether <code>Ext</code> is referentially transparent with regard to <code>eval</code>. It depends. What does &ldquo;reads a line&rdquo; mean, and what is &ldquo;standard input&rdquo; exactly? This is all part of a context that needs to be established.</p>

<p>Here&rsquo;s one implementation of an evaluator for Sigma, in Scala:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Ext</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">eval1</span><span class="o">(</span><span class="n">sig</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sigma</span> <span class="o">=</span> <span class="n">sig</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Ext</span> <span class="k">=&gt;</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">readLine</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, it&rsquo;s easy to see that the <code>Ext</code> instruction is <em>not</em> referentially transparent with regard to <code>eval1</code>. Replacing <code>Ext</code> with <code>eval1(ext)</code> does not preserve meaning. Consider this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Ext</span>
</span><span class='line'><span class="n">eval1</span><span class="o">(</span><span class="nc">Concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>VS this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="nc">Ext</span><span class="o">)</span>
</span><span class='line'><span class="n">eval1</span><span class="o">(</span><span class="nc">Concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s clearly not the same thing. The former will get two strings from standard input and concatenate them together. The latter will get only one string, store it as <code>x</code>, and return <code>x + x</code>.</p>

<p>Now consider a slightly different evaluator:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">eval2</span><span class="o">(</span><span class="n">sig</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">,</span> <span class="n">stdin</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sigma</span> <span class="o">=</span> <span class="n">sig</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval2</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval2</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Ext</span> <span class="k">=&gt;</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this case, the <code>Ext</code> instruction clearly <em>is</em> referentially transparent with regard to <code>eval2</code>, because our standard input is just a string, and it is always the same string. So you see, the purity of functions in the Sigma language very much depends on how that language is interpreted.</p>

<p>This is the reason why Haskell programs are considered &ldquo;pure&rdquo;, even in the presence of <code>IO</code>. A value of type <code>IO a</code> in Haskell is simply a function. Reducing it to normal form (evaluating it) has no effect. An <code>IO</code> action is of course not referentially transparent with regard to <code>unsafePerformIO</code>, but as long as your program does not use that it remains a referentially transparent expression.</p>

<h3>What purity is not</h3>

<p>In my experience there are more or less two camps into which unhelpful views on purity fall.</p>

<p>The first view, which we will call the <em>empiricist</em> view, is typically taken by people who understand &ldquo;pure&rdquo; as a pretentious term, meant to denegrate regular everyday programming as being somehow &ldquo;impure&rdquo; or &ldquo;unclean&rdquo;. They see purity as being &ldquo;academic&rdquo;, detached from reality, in an ivory tower, or the like.</p>

<p>This view is premised on a superficial understanding of purity. The assumption is that purity is somehow about the absence of I/O, or not mutating memory. But how could any programs be written that don&rsquo;t change the state of memory? At the end of the day, you have to update the CPU&rsquo;s registers, write to memory, and produce output on a display. A program has to make the computer <em>do something</em>, right? So aren&rsquo;t we just pretending that our programs don&rsquo;t run on real computers? Isn&rsquo;t it all just an academic exercise in making the CPU warm?</p>

<p>Well, no. That&rsquo;s not what purity means. Purity is not about the absence of program behaviors like I/O or mutable memory. It&rsquo;s about delimiting such behavior in a specific way.</p>

<p>The other view, which I will call the <em>rationalist</em> view, is typically taken by people with overexposure to modern analytic philosophy. Expressions are to be understood by their <em>denotation</em>, not by reference to any evaluator. Then of course every expression is really referentially transparent, and so purity is a distinction without a difference. After all, an imperative side-effectful C program can have the same denotation as a monadic, side-effect-free Haskell program. There is nothing wrong with this viewpoint, but it&rsquo;s not instructive <em>in this context</em>. Sure, when designing in the abstract, we can think denotationally without regard to evaluation. But when concretizing the design in terms of an actual programming language, we do need to be aware of how we expect evaluation to take place. And only then are referential transparency and purity useful concepts.</p>

<p>Both of these, the rationalist and empiricist views, conflate different levels of abstraction. A program written in a programming language is not the same thing as the physical machine that it may run on. Nor is it the same thing as the abstractions that capture its meaning.</p>

<h3>Further reading</h3>

<p>I highly recommend the paper <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;sqi=2&amp;ved=0CCMQFjAB&amp;url=http%3A%2F%2Fwww.cs.indiana.edu%2F~sabry%2Fpapers%2FpurelyFunctional.ps&amp;ei=I5NYUIRUqvXSAbC_gKgF&amp;usg=AFQjCNGwxjzB5zUBws6D9wnKPzo-zL57pw&amp;sig2=HgE-ZhzoIS19TEe2K2EW-Q"><em>What is a Purely Functional Language?</em></a> by Amr Sabry, although it deals with the idea of a <em>purely functional language</em> rather than purity of functions within a language that does not meet that criteria.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Beginnings]]></title>
    <link href="http://runarorama.github.com/blog/2012/09/04/this-blog-has-moved/"/>
    <updated>2012-09-04T01:29:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2012/09/04/this-blog-has-moved</id>
    <content type="html"><![CDATA[<p>I have not seriously updated the <a href="http://apocalisp.wordpress.com">old Apocalisp blog</a> for quite some time. Mostly this is due to the fact that I have been spending all of my creative time outside of work on <a href="http://manning.com/bjarnason">writing a book</a>. It&rsquo;s also partly that putting a post up on WordPress is a chore. It&rsquo;s like building a ship in a bottle.</p>

<p>So I have decided to make posting really easy for myself by hosting the blog <a href="http://github.com/runarorama/runarorama.github.com">on GitHub</a>. I am using a dead-simple markdown-based framework called <a href="http://octopress.org">Octopress</a>. With this setup I can very easily write a new post from my command line and publish by pushing to GitHub. This is already part of my normal coding workflow, so it feels more friction-free.</p>

<p>The new blog is simply titled &ldquo;Higher Order&rdquo;, and is available at <a href="http://blog.higher-order.com">blog.higher-order.com</a>. Check back soon for posts that I&rsquo;ve been sitting on but have been too <del>lazy</del> busy to post.</p>

<p>All of the old content and comments will still be available at the old address, and I&rsquo;ll probably cross-post to both places for a little while.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scalaz Tutorial: Enumeration-based I/O With Iteratees]]></title>
    <link href="http://runarorama.github.com/blog/2010/10/14/scalaz-tutorial-enumeration-based-io-with-iteratees/"/>
    <updated>2010-10-14T00:00:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2010/10/14/scalaz-tutorial-enumeration-based-io-with-iteratees</id>
    <content type="html"><![CDATA[<p><a href="http://scalaz.org">Scalaz</a> 5.0 adds an implementation of a concept called Iteratee. This is a highly flexible programming technique for writing enumeration-based input processors that can be freely composed.</p>

<p>A lot of people have asked me to write a tutorial on how this works, specifically on how it is implemented in Scalaz and how to be productive with it, so here we go.</p>

<p>The implementation in Scalaz is based on an excellent article by John W. Lato called <a href="http://themonadreader.files.wordpress.com/2010/05/issue16.pdf">“Iteratee: Teaching an Old Fold New Tricks”</a>. As a consequence, this post is also based on that article, and because I am too unoriginal to come up with my own examples, the examples are directly translated from it. The article gives code examples in Haskell, but we will use Scala here throughout.</p>

<h2>Motivation</h2>

<p>Most programmers have come across the problem of treating an I/O data source (such as a file or a socket) as a data structure. This is a common thing to want to do. To contrast, the usual means of reading, say, a file, is to open it, get a cursor into the file (such as a FileReader or an InputStream), and read the contents of the file as it is being processed. You must of course handle IO exceptions and remember to close the file when you are done. The problem with this approach is that it is not modular. Functions written in this way are performing one-off side-effects. And as we know, side-effects do not compose.</p>

<p>Treating the stream of inputs as an enumeration is therefore desirable. It at least holds the lure of modularity, since we would be able to treat a File, from which we’re reading values, in the same way that we would treat an ordinary List of values, for example.</p>

<p>A naive approach to this is to use iterators, or rather, Iterables. This is akin to the way that you would typically read a file in something like Ruby or Python. Basically you treat it as a collection of Strings:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">getContents</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">fr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">fileName</span><span class="o">))</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">iterator</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">hasNext</span> <span class="k">=</span> <span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">next</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">retVal</span> <span class="k">=</span> <span class="n">line</span>
</span><span class='line'>        <span class="n">line</span> <span class="k">=</span> <span class="n">getLine</span>
</span><span class='line'>        <span class="n">retVal</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">getLine</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="n">line</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">line</span> <span class="k">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">readLine</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">line</span> <span class="k">=</span> <span class="kc">null</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">line</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="n">getLine</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What this is doing is a kind of lazy I/O. Nothing is read from the file until it is requested, and we only hold one line in memory at a time. But there are some serious issues with this approach. It’s not clear when you should close the file handle, or whose responsibility that is. You could have the Iterator close the file when it has read the last line, but what if you only want to read part of the file? Clearly this approach is not sufficient. There are some things we can do to make this more sophisticated, but only at the expense of breaking the illusion that the file really is a collection of Strings.</p>

<h2>The Idea</h2>

<p>Any functional programmer worth their salt should be thinking right about now: “Instead of getting Strings out of the file, just pass in a function that will serve as a handler for each new line!” Bingo. This is in fact the plot with Iteratees. Instead of implementing an interface from which we request Strings by pulling, we’re going to give an implementation of an interface that can receive Strings by pushing.</p>

<p>And indeed, this idea is nothing new. This is exactly what we do when we fold a list:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldLeft</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>The second argument is exactly that, a handler for each element in the list, along with a means of combining it with the accumulated value so far.</p>

<p>Now, there are two issues with an ordinary fold that prevent it from being useful when enumerating file contents. Firstly, there is no way of indicating that the fold should stop early. Secondly, a list is held all in memory at the same time.</p>

<h2>The Iteratee Solution</h2>

<p>Scalaz defines the following two data structures (actual implementation may differ, but this serves for illustration):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">+E</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">El</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">EOF</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// Implementation omitted</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Done</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>So an input to an iteratee is represented by Input[E], where E is the element type of the input source. It can be either an element (the next element in the file or stream), or it’s one of two signals: Empty or EOF. The Empty signal tells the iteratee that there is not an element available, but to expect more elements later. The EOF signal tells the iteratee that there are no more elements to be had.</p>

<p>Note that this particular set of signals is kind of arbitrary. It just facilitates a particular set of use cases. There’s no reason you couldn’t have other signals for other use cases. For example, a signal I can think of off the top of my head would be Restart, which would tell the iteratee to start its result from scratch at the current position in the input.</p>

<p>IterV[E,A] represents a computation that can be in one of two states. It can be Done, in which case it will hold a result (the accumulated value) of type A. Or it can be waiting for more input of type E, in which case it will hold a continuation that accepts the next input.</p>

<p>Let’s see how we would use this to process a List. The following function takes a list and an iteratee and feeds the list’s elements to the iteratee.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">enumerate</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">E</span><span class="o">],</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">i</span><span class="nd">@Done</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">i</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">enumerate</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">k</span><span class="o">(</span><span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now let’s see some actual iteratees. As a simple example, here is an iteratee that counts the number of elements it has seen:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">counter</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And here’s an iteratee that discards the first n elements:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">drop</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">drop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">((),</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Done</span><span class="o">((),</span> <span class="nc">Empty</span><span class="o">)</span> <span class="k">else</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And one that takes the first element from the input:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">head</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let’s go through this code. Each one defines a “step” function, which is the function that will handle the next input. Each one starts the iteratee in the Cont state, and the step function always returns a new iteratee in the next state based on the input received. Note in the last one (head), we are using the Empty signal to indicate that we want to remove the element from the input. The utility of this will be clear when we start composing iteratees.</p>

<p>Now, an example usage. To get the length of a list, we write:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">enumerate</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="n">counter</span><span class="o">[</span><span class="kt">Int</span><span class="o">]).</span><span class="n">run</span> <span class="c1">// 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>The run method on IterV just gets the accumulated value out of the Done iteratee. If it isn’t done, it sends the EOF signal to itself first and then gets the value.</p>

<h2>Composing Iteratees</h2>

<p>Notice a couple of things here. With iteratees, the input source can send the signal that it has finished producing values. And on the other side, the iteratee itself can signal to the input source that it has finished consuming values. So on one hand, we can leave an iteratee “running” by not sending it the EOF signal, so we can compose two input sources and feed them into the same iteratee. On the other hand, an iteratee can signal that it’s done, at which point we can start sending any remaining elements to another iteratee. In other words, iteratees compose sequentially.</p>

<p>In fact, IterV[E,A] is an instance of the Monad type class for each fixed E, and composition is very similar to the way monadic parsers compose:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Done</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Done</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here then is an example of composing iteratees with a for-comprehension:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">drop1Keep1</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">drop</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">head</span>
</span><span class='line'><span class="o">}</span> <span class="k">yield</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>The iteratee above discards the first element it sees and returns the second one. The iteratee below does this n times, accumulating the kept elements into a list.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">alternates</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">drop1Keep1</span><span class="o">[</span><span class="kt">E</span><span class="o">].</span>
</span><span class='line'>    <span class="n">replicate</span><span class="o">[</span><span class="kt">List</span><span class="o">](</span><span class="n">n</span><span class="o">).</span>
</span><span class='line'>    <span class="n">foldRight</span><span class="o">(</span><span class="nc">Done</span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]](),</span><span class="nc">Empty</span><span class="o">))((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">h</span> <span class="k">&lt;-</span> <span class="n">x</span>
</span><span class='line'>      <span class="n">t</span> <span class="k">&lt;-</span> <span class="n">y</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">flatten</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here’s an example run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala> enumerate(List.range(1,15), alternates[Int](5)).run
</span><span class='line'>res85: List[Int] = List(2, 4, 6, 8, 10)</span></code></pre></td></tr></table></div></figure>


<h2>File Input With Iteratees</h2>

<p>Using the iteratees to read from file input turns out to be incredibly easy. The only difference is in how the data source is enumerated, and in order to remain lazy (and not prematurely perform any side-effects), we must return our iteratee in a monad:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">enumReader</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">,</span>
</span><span class='line'>                  <span class="n">it</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">loop</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">i</span><span class="nd">@Done</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">i</span> <span class="o">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">i</span><span class="nd">@Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">s</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">r</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
</span><span class='line'>      <span class="n">a</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">i</span> <span class="o">}</span> <span class="k">else</span> <span class="n">loop</span><span class="o">(</span><span class="n">k</span><span class="o">(</span><span class="nc">El</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="n">loop</span><span class="o">(</span><span class="n">it</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The monad being used here is an IO monad that I’ll explain in a second. The important thing to note is that the iteratee is completely oblivious to the fact that it’s being fed lines from a BufferedReader rather than a List.</p>

<p>Here is the IO monad I’m using. As you can see, it’s really just a lazy identity monad:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">io</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">unsafePerformIO</span><span class="k">:</span> <span class="kt">A</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">object</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">unsafePerformIO</span> <span class="k">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">IOMonad</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">implicitly</span><span class="o">[</span><span class="kt">Monad</span><span class="o">[</span><span class="kt">Function0</span><span class="o">]].</span><span class="n">bind</span><span class="o">(</span>
</span><span class='line'>        <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">unsafePerformIO</span><span class="o">,</span>
</span><span class='line'>        <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="n">unsafePerformIO</span><span class="o">)()</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>To read lines from a file, we’ll do something like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">bufferFile</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">closeReader</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Reader</span><span class="o">)</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">r</span><span class="o">.</span><span class="n">close</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">bracket</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
</span><span class='line'>                   <span class="n">fin</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span>
</span><span class='line'>                   <span class="n">body</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'><span class="k">for</span> <span class="o">{</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">init</span>
</span><span class='line'>      <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">body</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">fin</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>  <span class="k">yield</span> <span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">enumFile</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">bracket</span><span class="o">(</span><span class="n">bufferFile</span><span class="o">(</span><span class="n">f</span><span class="o">),</span>
</span><span class='line'>          <span class="n">closeReader</span><span class="o">(</span><span class="k">_:</span><span class="kt">BufferedReader</span><span class="o">),</span>
</span><span class='line'>          <span class="n">enumReader</span><span class="o">(</span><span class="k">_:</span><span class="kt">BufferedReader</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The enumFile method uses bracketing to ensure that the file always gets closed. It’s completely lazy though, so nothing actually happens until you call unsafePerformIO on the resulting IO action:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala> enumFile(new File("/Users/runar/Documents/Iteratees.txt"), head) map (_.run)                
</span><span class='line'>res2: io.IO[Option[String]] = io$IO@5f90b584
</span><span class='line'>
</span><span class='line'>scala> res2.unsafePerformIO
</span><span class='line'>res3: Option[String] = Some(Scalaz Tutorial: Enumeration-Based I/O With Iteratees)</span></code></pre></td></tr></table></div></figure>


<p>That uses the “head” iteratee from above to get the first line of the file that I’m using to edit this blog post.</p>

<p>We can get the number of lines in two files combined, by composing two enumerations and using our “counter” iteratee from above:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">lengthOfTwoFiles</span><span class="o">(</span><span class="n">f1</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">f2</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">l1</span> <span class="k">&lt;-</span> <span class="n">enumFile</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">counter</span><span class="o">)</span>
</span><span class='line'>  <span class="n">l2</span> <span class="k">&lt;-</span> <span class="n">enumFile</span><span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">l1</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span> <span class="k">yield</span> <span class="n">l2</span><span class="o">.</span><span class="n">run</span>
</span></code></pre></td></tr></table></div></figure>


<p>So what we have here is a uniform and compositional interface for enumerating both pure and effectful data sources. We can avoid holding on to the entire input in memory when we don’t want to, and we have complete control over when to stop iterating. The iteratee can decide whether to consume elements, leave them intact, or even truncate the input. The enumerator can decide whether to shut the iteratee down by sending it the EOF signal, or to leave it open for other enumerators.</p>

<p>There is even more to this approach, as we can use iteratees not just to read from data sources, but also to write to them. That will have to await another post.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Structural Pattern Matching in Java]]></title>
    <link href="http://runarorama.github.com/blog/2009/08/21/structural-pattern-matching-in-java/"/>
    <updated>2009-08-21T00:00:00-04:00</updated>
    <id>http://runarorama.github.com/blog/2009/08/21/structural-pattern-matching-in-java</id>
    <content type="html"><![CDATA[<p>(updated for Java 8)</p>

<p>One of the great features of modern programming languages is structural pattern matching on algebraic data types. Once you&rsquo;ve used this feature, you don&rsquo;t ever want to program without it. You will find this in languages like Haskell and Scala.</p>

<p>In Scala, algebraic types are provided by case classes. For example:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Tree</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Tree</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
</span></code></pre></td></tr></table></div></figure>


<p>To define operations over this algebraic data type, we use pattern matching on its structure:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">depth</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">t</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="mi">0</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Leaf</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">depth</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">depth</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>When I go back to a programming language like, say, Java, I find myself wanting this feature. Unfortunately, algebraic data types aren&rsquo;t provided in Java. However, a great many hacks have been invented over the years to emulate it, knowingly or not.</p>

<h3>The Ugly: Interpreter and Visitor</h3>

<p>What I have used most throughout my career to emulate pattern matching in languages that lack it are a couple of hoary old hacks. These venerable and well respected practises are a pair of design patterns from the GoF book: Interpreter and Visitor.</p>

<p>The Interpreter pattern really does describe an algebraic structure, and it provides a method of reducing (interpreting) the structure. However, there are a couple of problems with it. The interpretation is coupled to the structure, with a &ldquo;context&rdquo; passed from term to term, and each term must know how to mutate the context appropriately. That&rsquo;s minus one point for tight coupling, and minus one for relying on mutation.</p>

<p>The Visitor pattern addresses the former of these concerns. Given an algebraic structure, we can define an interface with one &ldquo;visit&rdquo; method per type of term, and have each term accept a visitor object that implements this interface, passing it along to the subterms. This decouples the interpretation from the structure, but still relies on mutation. Minus one point for mutation, and minus one for the fact that Visitor is incredibly crufty. For example, to get the depth of our tree structure above, we have to implement a TreeDepthVisitor. A good IDE that generates boilerplate for you is definitely recommended if you take this approach.</p>

<p>On the plus side, both of these patterns provide some enforcement of the exhaustiveness of the pattern match. For example, if you add a new term type, the Interpreter pattern will enforce that you implement the interpretation method. For Visitor, as long as you remember to add a visitation method for the new term type to the visitor interface, you will be forced to update your implementations accordingly.</p>

<h3>The Bad: Instanceof</h3>

<p>An obvious approach that&rsquo;s often sneered at is runtime type discovery. A quick and dirty way to match on types is to simply check for the type at runtime and cast:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">depth</span><span class="o">(</span><span class="n">Tree</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">Empty</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">Leaf</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="n">Node</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">depth</span><span class="o">(((</span><span class="n">Node</span><span class="o">)</span> <span class="n">t</span><span class="o">).</span><span class="na">left</span><span class="o">),</span> <span class="n">depth</span><span class="o">(((</span><span class="n">Node</span><span class="o">)</span> <span class="n">t</span><span class="o">).</span><span class="na">right</span><span class="o">));</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;Inexhaustive pattern match on Tree.&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>There are some obvious problems with this approach. For one thing, it bypasses the type system, so you lose any static guarantees that it&rsquo;s correct. And there&rsquo;s no enforcement of the exhaustiveness of the matching. But on the plus side, it&rsquo;s both fast and terse.</p>

<h3>The Good: Functional Style</h3>

<p>There are at least two approaches that we can take to approximate pattern matching in Java more closely than the above methods. Both involve utilising parametric polymorphism and functional style. Let&rsquo;s consider them in order of increasing preference, i.e. less preferred method first.</p>

<h4>Safe and Terse - Disjoint Union Types</h4>

<p>The first approach is based on the insight that algebraic data types represent a disjoint union of types. Now, if you&rsquo;ve done any amount of programming in Java with generics, you will have come across (or invented) the simple pair type, which is a conjunction of two types:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">P2</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">A</span> <span class="nf">_1</span><span class="o">();</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">B</span> <span class="nf">_2</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>A value of this type can only be created if you have both a value of type <code>A</code> and a value of type <code>B</code>. So (conceptually, at least) it has a single constructor that takes two values. The disjunction of two types is a similar idea, except that a value of type <code>Either&lt;A, B&gt;</code> can be constructed with either a value of type <code>A</code> or a value of type <code>B</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Either</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="nf">left</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="nf">right</span><span class="o">(</span><span class="n">B</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Encoded as a disjoint union type, then, our <code>Tree</code> data type above is: <code>Either&lt;Empty, Either&lt;Leaf, Node&gt;&gt;</code></p>

<p>Let&rsquo;s see that in context. Here&rsquo;s the code.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Tree</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Constructor private so the type is sealed.</span>
</span><span class='line'>  <span class="kd">private</span> <span class="nf">Tree</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">abstract</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="nf">toEither</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Empty</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">toEither</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">left</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Empty</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Leaf</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="nf">toEither</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">right</span><span class="o">(</span><span class="n">Either</span><span class="o">.&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span><span class="n">left</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Leaf</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tree</span> <span class="n">left</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tree</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="nf">toEither</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">right</span><span class="o">(</span><span class="n">Either</span><span class="o">.&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span><span class="n">right</span><span class="o">(</span><span class="k">this</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Tree</span> <span class="n">left</span><span class="o">,</span> <span class="n">Tree</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The neat thing is that <code>Either&lt;A, B&gt;</code> can be made to return both <code>Iterable&lt;A&gt;</code> and <code>Iterable&lt;B&gt;</code> in methods <code>right()</code> and <code>left()</code>, respectively. One of them will be empty and the other will have exactly one element. So our pattern matching function will look like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">depth</span><span class="o">(</span><span class="n">Tree</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Either</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">eln</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">toEither</span><span class="o">();</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="n">Empty</span> <span class="nl">e:</span> <span class="n">eln</span><span class="o">.</span><span class="na">left</span><span class="o">())</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="n">Either</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="nl">ln:</span> <span class="n">eln</span><span class="o">.</span><span class="na">right</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="nl">leaf:</span> <span class="n">ln</span><span class="o">.</span><span class="na">left</span><span class="o">())</span>
</span><span class='line'>      <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="nl">node:</span> <span class="n">ln</span><span class="o">.</span><span class="na">right</span><span class="o">())</span>
</span><span class='line'>      <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">depth</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">depth</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">&quot;Inexhaustive pattern match on Tree.&quot;</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s terse and readable, as well as type-safe. The only issue with this is that the exhaustiveness of the patterns is not enforced, so we&rsquo;re still only discovering that error at runtime. So it&rsquo;s not all that much of an improvement over the instanceof approach.</p>

<h4>Safe and Exhaustive: Church Encoding</h4>

<p>Alonzo Church was a pretty cool guy. Having invented the lambda calculus, he discovered that you could encode data in it. We&rsquo;ve all heard that every data type can be defined in terms of the kinds of operations that it supports. Well, what Church discovered is much more profound than that. A data type IS a function. In other words, an algebraic data type is not just a structure together with an algebra that collapses the structure. The algebra IS the structure.</p>

<p>Consider the boolean type. It is a disjoint union of True and False. What kinds of operations does this support? Well, you might want to do one thing if it&rsquo;s True, and another if it&rsquo;s False. Just like with our Tree, where we wanted to do one thing if it&rsquo;s a Leaf, and another thing if it&rsquo;s a Node, etc.</p>

<p>But it turns out that the boolean type IS the condition function. Consider the Church encoding of booleans:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>true  = λa.λb.a
</span><span class='line'>false = λa.λb.b</span></code></pre></td></tr></table></div></figure>


<p>So a boolean is actually a binary function. Given two terms, a boolean will yield the former term if it&rsquo;s true, and the latter term if it&rsquo;s false. What does this mean for our <code>Tree</code> type? It too is a function:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>empty = λa.λb.λc.a
</span><span class='line'>leaf  = λa.λb.λc.λx.b x
</span><span class='line'>node  = λa.λb.λc.λl.λr.c l r</span></code></pre></td></tr></table></div></figure>


<p>You can see that this gives you pattern matching for free. The <code>Tree</code> type is a function that takes three arguments:</p>

<p>A value to yield if the tree is empty.
A unary function to apply to an integer if it&rsquo;s a leaf.
A binary function to apply to the left and right subtrees if it&rsquo;s a node.
The type of such a function looks like this (Scala notation):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">T</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Tree</span> <span class="k">=&gt;</span> <span class="nc">Tree</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span>
</span></code></pre></td></tr></table></div></figure>


<p>Or equivalently:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="nc">Node</span> <span class="k">=&gt;</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">T</span>
</span></code></pre></td></tr></table></div></figure>


<p>Translated to Java, we need this method on Tree:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                            <span class="n">Function</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                            <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>Function</code> interface is in the <code>java.util</code> package in Java 8, but you can definitely make it yourself in previous versions:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">&gt;</span> <span class="o">{</span> <span class="kd">public</span> <span class="n">B</span> <span class="nf">apply</span><span class="o">(</span><span class="n">A</span> <span class="n">a</span><span class="o">);</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now our Tree code looks like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Tree</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// Constructor private so the type is sealed.</span>
</span><span class='line'>  <span class="kd">private</span> <span class="nf">Tree</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">abstract</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                              <span class="n">Function</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                              <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Empty</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Funciton</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Empty</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Leaf</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Leaf</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="kd">extends</span> <span class="n">Tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tree</span> <span class="n">left</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Tree</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">match</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;</span><span class="n">Empty</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Leaf</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Function</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">Tree</span> <span class="n">left</span><span class="o">,</span> <span class="n">Tree</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And we can do our pattern matching on the calling side:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">depth</span><span class="o">(</span><span class="n">Tree</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">match</span><span class="o">((</span><span class="n">Empty</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span>
</span><span class='line'>                 <span class="o">(</span><span class="n">Leaf</span> <span class="n">l</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span>
</span><span class='line'>                 <span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="o">(</span><span class="n">depth</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">depth</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is almost as terse as the Scala code, and very easy to understand. Everything is checked by the type system, and we are guaranteed that our patterns are exhaustive. This is an ideal solution.</p>

<h3>Conclusion</h3>

<p>With some slightly clever use of generics and a little help from our friends Church and Curry, we can indeed emulate structural pattern matching over algebraic data types in Java, to the point where it&rsquo;s almost as nice as a built-in language feature.</p>

<p>So throw away your Visitors and set fire to your GoF book.</p>
]]></content>
  </entry>
  
</feed>
