
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Higher Order</title>
  <meta name="author" content="RÃºnar Bjarnason">

  
  <meta name="description" content="Today I want to talk about relationships between monoids. These can be useful to think about when we&#8217;re developing libraries involving monoids &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://runarorama.github.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Higher Order" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script type="text/javascript" src="//use.typekit.net/fbs7fzv.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34544663-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Higher Order</a></h1>
  
    <h2>Philosophy and functional programming.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:runarorama.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/03/19/monoid-morphisms-products-coproducts/">Monoid Morphisms, Products, and Coproducts</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-03-19T00:00:00-04:00" pubdate data-updated="true">Mar 19<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Today I want to talk about relationships between monoids. These can be useful to think about when we&#8217;re developing libraries involving monoids, and we want to express some algebraic laws among them. We can then check these with automated tests, or indeed <em>prove</em> them with algebraic reasoning.</p>

<p>This post kind of fell together when writing notes on chapter 10, &#8220;Monoids&#8221;, of <a href="http://manning.com/bjarnason">Functional Programming in Scala</a>. I am putting it here so I can reference it from the chapter notes at the end of the book.</p>

<h2>Monoid homomorphisms</h2>

<p>Let&#8217;s take the <code>String</code> concatenation and <code>Int</code> addition as example monoids that have a relationship. Note that if we take the length of two strings and add them up, this is the same as concatenating those two strings and taking the length of the combined string:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">).</span><span class="n">length</span>
</span></code></pre></td></tr></table></div></figure>


<p>So every <code>String</code> maps to a corresponding <code>Int</code> (its length), and every concatenation of strings maps to the addition of corresponding lengths.</p>

<p>The <code>length</code> function maps from <code>String</code> to <code>Int</code> <em>while preserving the monoid structure</em>. Such a function, that maps from one monoid to another in such a preserving way, is called a <em>monoid homomorphism</em>. In general, for monoids <code>M</code> and <code>N</code>, a homomorphism <code>f: M =&gt; N</code>, and all values <code>x:M</code>, <code>y:M</code>, the following law holds:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">f</span><span class="o">(</span><span class="n">x</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">f</span><span class="o">(</span><span class="n">y</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>|+|</code> syntax is from <a href="http://github.com/scalaz/scalaz">Scalaz</a> and is obtained by importing <code>scalaz.syntax.monoid._</code>. It just references the <code>append</code> method on the <code>Monoid[T]</code> instance, where <code>T</code> is the type of the arguments.</p>

<p>This law can have real practical benefits. Imagine for example a &#8220;result set&#8221; monoid that tracks the locations of a particular set of records in a database or file. This could be as simple as a <code>Set</code> of locations. Concatenating several thousand files and then proceeding to search through them is going to be much slower than searching through the files individually and then concatenating the result sets. Particularly since we can potentially search the files in parallel. A good automated test for our result set monoid would be that it admits a homomorphism from the data file monoid.</p>

<h2>Monoid isomorphisms</h2>

<p>Sometimes there will be a homomorphism in both directions between two monoids. If these are inverses of one another, then this kind of relationship is called a <em>monoid isomorphism</em> and we say that the two monoids are isomorphic. More precisely, we will have two monoids <code>A</code> and <code>B</code>, and homomorphisms <code>f: A =&gt; B</code> and <code>g: B =&gt; A</code>. If <code>f(g(b)) == b</code> and <code>g(f(a)) == a</code>, for all <code>a:A</code> and <code>b:B</code> then <code>f</code> and <code>g</code> form an isomorphism.</p>

<p>For example, the <code>String</code> and <code>List[Char]</code> monoids with concatenation are isomorphic. We can convert a <code>String</code> to a <code>List[Char]</code>, preserving the monoid structure, and we can go back again to a <code>String</code> to end up with the same element of the same monoid we started with.</p>

<p>Note that there are monoids with homomorphisms in both directions between them that nevertheless are <em>not</em> isomorphic.</p>

<h2>Monoid products and coproducts</h2>

<p>If <code>A</code> and <code>B</code> are monoids, then <code>(A,B)</code> is certainly a monoid, called their <em>product</em>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">product</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">),</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="k">=</span>
</span><span class='line'>      <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">_1</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_2</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">zero</span> <span class="k">=</span> <span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But is there such a thing as a monoid <em>coproduct</em>? It&#8217;s certainly not possible to build a monoid on <code>Either[A,B]</code> for monoids <code>A</code> and <code>B</code>. For example, what would be the <code>zero</code> of such a monoid? And what would be the value of <code>Left(a) |+| Right(b)</code>? We could certainly choose an arbitrary rule, but not one that actually satisfies the monoid laws of associativity and unit.</p>

<p>To resolve this, we need to know the precise meaning of <em>product</em> and <em>coproduct</em>. These come straight from Wikipedia, with a little help from Cale Gibbard.</p>

<p>A <em>product</em> <code>M</code> of two monoids <code>A</code> and <code>B</code> is a monoid such that there exist homomorphisms <code>fst: M =&gt; A</code>, <code>snd: M =&gt; B</code>, and for any monoid <code>Z</code> and morphisms <code>f: Z =&gt; A</code> and <code>g: Z =&gt; B</code> there has to be a unique homomorphism <code>h: Z =&gt; M</code> such that <code>fst(h(z)) == f(z)</code> and <code>snd(h(z)) == g(z)</code> for all <code>z:Z</code>. In other words, the following diagram must commute:</p>

<p><img src="/images/Product.png"></p>

<p>A <em>coproduct</em> <code>W</code> of two monoids <code>A</code> and <code>B</code> is the same except the arrows are reversed. It&#8217;s a monoid such that there exist homomorphisms <code>left: A =&gt; W</code>, <code>right: B =&gt; W</code>, and for any monoid <code>Z</code> and morphisms <code>f: A =&gt; Z</code> and <code>g: B =&gt; Z</code> there has to be a unique homomorphism <code>h: W =&gt; Z</code> such that <code>h(left(a)) == f(a)</code> and <code>h(right(b)) == g(b)</code> for all <code>a:A</code> and all <code>b:B</code>. In other words, the following diagram must commute:</p>

<p><img src="/images/Coproduct.png"></p>

<p>We can easily show that our <code>productMonoid</code> above really is a monoid product. The homomorphisms are the methods <code>_1</code> and <code>_2</code> on <code>Tuple2</code>. They simply map every element of <code>(A,B)</code> to a corresponding element in <code>A</code> and <code>B</code>. The monoid structure is preserved because:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">p</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">).</span><span class="n">_1</span> <span class="o">==</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_1</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'><span class="o">(</span><span class="n">p</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">).</span><span class="n">_2</span> <span class="o">==</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_2</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>And for any other monoid <code>Z</code>, and morphisms <code>f: Z =&gt; A</code> and <code>g: Z =&gt; B</code>, we can construct a unique morphism from <code>Z</code> to <code>(A,B)</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">factor</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">Z</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">z</span><span class="o">),</span> <span class="n">g</span><span class="o">(</span><span class="n">z</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And this really is a homomorphism because we just inherit the homomorphism law from <code>f</code> and <code>g</code>.</p>

<p>What does a coproduct then look like? Well, it&#8217;s going to be a type <code>C[A,B]</code> together with an instance <code>coproduct[A:Monoid,B:Monoid]:Monoid[C[A,B]]</code>. It will be equipped with two monoid homomorphisms, <code>left: A =&gt; C[A,B]</code> and <code>right: B =&gt; C[A,B]</code> that satisfy the following (according to the monoid homomorphism law):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">a1</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">left</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span> <span class="o">==</span> <span class="n">left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span>
</span><span class='line'><span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">b1</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">right</span><span class="o">(</span><span class="n">b2</span><span class="o">))</span> <span class="o">==</span> <span class="n">right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>And additionally, for any other monoid <code>Z</code> and homomorphisms <code>f: A =&gt; Z</code> and <code>g: B =&gt; Z</code> we must be able to construct a unique homomorphism from <code>C[A,B]</code> to <code>Z</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Free products of monoids</h3>

<p>We can simply come up with a data structure required for the coproduct to satisfy a monoid. We will start with two constructors, one for the left side, and another for the right side:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">This</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">That</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This certainly allows an embedding of both monoids <code>A</code> and <code>B</code>. But <code>These</code> is now basically <code>Either</code>, which we know doesn&#8217;t quite form a monoid. What&#8217;s needed is a <code>zero</code>, and a way of appending an <code>A</code> to a <code>B</code>. The simplest way to do that is to add a product constructor to <code>These</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Both</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now <code>These[A,B]</code> is a monoid as long as <code>A</code> and <code>B</code> are monoids:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">coproduct</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">These</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">These</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">These</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">These</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">This</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="nc">This</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">This</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">That</span><span class="o">(</span><span class="n">b1</span><span class="o">),</span> <span class="nc">That</span><span class="o">(</span><span class="n">b2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">That</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">That</span><span class="o">(</span><span class="n">b</span><span class="o">),</span> <span class="nc">This</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">This</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="nc">That</span><span class="o">(</span><span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Both</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="nc">This</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b1</span><span class="o">),</span> <span class="nc">That</span><span class="o">(</span><span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b1</span> <span class="o">|+|</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">This</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">That</span><span class="o">(</span><span class="n">b</span><span class="o">),</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b1</span> <span class="o">|+|</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Both</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">),</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">,</span> <span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">zero</span> <span class="k">=</span> <span class="nc">Both</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">zero</span><span class="o">,</span> <span class="n">B</span><span class="o">.</span><span class="n">zero</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>These[A,B]</code> is the smallest and most general monoid that contains both <code>A</code> and <code>B</code> as submonoids (the <code>This</code> and <code>That</code> constructors, respectively) and admits a homomorphism from both <code>A</code> and <code>B</code>. And notice that we simply added the least amount of structure possible to make <code>These[A,B]</code> a monoid (the <code>Both</code> constructor). For this reason it is a <em>free product</em>. It also satisfies the criteria of a <em>monoid coproduct</em>. I will demonstrate that now.</p>

<p>First we must prove that <code>This</code> and <code>That</code> really are homomorphisms. We need to prove the following two properties:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="nc">This</span><span class="o">(</span><span class="n">a1</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">This</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span> <span class="o">==</span> <span class="nc">This</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span>
</span><span class='line'><span class="o">(</span><span class="nc">That</span><span class="o">(</span><span class="n">b1</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">That</span><span class="o">(</span><span class="n">b2</span><span class="o">))</span> <span class="o">==</span> <span class="nc">That</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&#8217;s easy. The first two cases of the <code>append</code> method on the <code>coproduct</code> monoid prove these properties.</p>

<p>But can we define <code>fold</code>? Yes we can:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span>
</span><span class='line'>  <span class="n">these</span><span class="k">:</span> <span class="kt">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">these</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">This</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">That</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And <code>fold</code> really is a homomorphism if <code>f</code> and <code>g</code> are. I&#8217;ll leave proving that fact as an exercise for the reader. It&#8217;s straightforward but relatively tedious to do with case analysis on two of <code>These</code>. Also prove that <code>coproduct[A,B]</code> obeys the monoid laws if you like, since I haven&#8217;t done that here.</p>

<h3>Free monoids on coproducts</h3>

<p>We can also go the other way. Instead of getting to the coproduct via a free product on the monoids, we can get there via a free monoid on the coproduct of the underlying sets.</p>

<p>The underlying set of a monoid <code>A</code> is just the type <code>A</code> without the monoid structure. The coproduct of types <code>A</code> and <code>B</code> is the type <code>Either[A,B]</code>. Having &#8220;forgotten&#8221; the monoid structure of both <code>A</code> and <code>B</code>, we can recover it by generating a free monoid on <code>Either[A,B]</code>, which is just <code>List[Either[A,B]]</code>. The <code>append</code> operation of this monoid is list concatenation, and the identity for it is the empty list.</p>

<p>Clearly <code>List[Either[A,B]]</code> is a monoid, but does it permit a homomorphism from both monoids <code>A</code> and <code>B</code>? If so, then the following properties should hold:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">))</span>
</span><span class='line'><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">))</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>They clearly do not hold! The lists on the left of <code>==</code> will have two elements and the lists on the right will have one element. What&#8217;s going on here?</p>

<p>Well, the fact is that <code>List[Either[A,B]]</code> is not exactly the monoid coproduct of <code>A</code> and <code>B</code>. It&#8217;s &#8220;too big&#8221; in a sense. But if we were to reduce the list to a normal form that approximates a &#8220;free product&#8221;, we can get a coproduct that matches our definition above. What we need is a new monoid:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">class</span> <span class="nc">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="k">val</span> <span class="n">toList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]])</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">++(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Eithers</span><span class="o">(</span><span class="n">toList</span> <span class="o">++</span> <span class="n">p</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">Eithers</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">xs</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]())</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">),</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Eithers[A,B]</code> is a kind of <code>List[Either[A,B]]</code> that has been normalized so that consecutive <code>A</code>s and consecutive <code>B</code>s have been collapsed using their respective monoids. So it will contain alternating <code>A</code> and <code>B</code> values.</p>

<p>This is now a monoid coproduct because it permits monoid homomorphisms from <code>A</code> and <code>B</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">)))</span> <span class="o">++</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">))))</span> <span class="o">==</span>
</span><span class='line'>  <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)))</span>
</span><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">)))</span> <span class="o">++</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">))))</span> <span class="o">==</span>
</span><span class='line'>  <span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And we can implement the <code>fold</code> homomorphism:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span>
</span><span class='line'>  <span class="n">es</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">es</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">Z</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">z</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">z</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But what on Earth does this representation of the coproduct have to do with the one above? At first glance, they seem to have absolutely nothing in common. One is a list and the oher is just a non-recursive algebraic data type.</p>

<p>But they do in fact have a relationship:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">toThese</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">es</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">es</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="nc">Both</span><span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">]))</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="nc">This</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">This</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">),</span> <span class="nc">That</span><span class="o">(</span><span class="n">b2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">That</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">),</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">toEithers</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">these</span><span class="k">:</span> <span class="kt">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">these</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">This</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">That</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)))</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What kind of relationship is this? It&#8217;s definitely not a plain isomorphism. Although <code>toThese(toEithers(t))</code> is always equal to <code>t</code>, it&#8217;s not true that <code>toEithers(toThese(es))</code> is always equal to <code>es</code>. You may start out with <code>es</code> having thousands of elements, but the result of <code>toEithers(toThese(es))</code> will always have either one or two elements. We really want to compare <code>toThese(toEithers(toThese(es)))</code> with <code>toThese(es)</code>. Those two are definitely always the same, for any <code>es</code>. We can conclude that each monoid admits an injection into the other, but <code>Eithers[A,B]</code> is in some sense &#8220;the same, only bigger&#8221;.</p>

<h3>From coproducts back to products</h3>

<p>Notice that in the definition of <code>toThese</code>, we are considering the case where the accumulated <code>These</code> is <code>This</code> or <code>That</code>. But those cases can never happen! We start the fold with a <code>Both</code>, so it will remain a <code>Both</code>. This is a hint that we could be expressing this relationship through just the monoid product <code>(A,B)</code>.</p>

<p>The fact is that both forms of the coproduct, <code>These[A,B]</code> and <code>Eithers[A,B]</code>, admit a homomorphism into the product <code>(A,B)</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldThese</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">these</span><span class="k">:</span> <span class="kt">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">these</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">This</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">That</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Both</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">foldEithers</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">es</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">es</span><span class="o">.</span><span class="n">foldMap</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>There is also a homomorphism in the other direction (but decidedly not an isomorphism):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">these</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Both</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">))</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="n">_2</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>So <code>These</code> and <code>Eithers</code> are in some sense abstractly &#8220;the same&#8221; with regard to the monoids <code>A</code> and <code>B</code>, and their product <code>(A,B)</code>. It&#8217;s essentially the same relationship as between the monoids <code>A</code> and the free monoid <code>List[A]</code> on the underlying set of <code>A</code>. The latter is just &#8220;strictly bigger&#8221; than the former.</p>

<p>Does anyone know a satisfying name for this relationship?</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/01/free-and-yoneda/">Free Monads and the Yoneda Lemma</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-01T00:00:00-04:00" pubdate data-updated="true">Nov 1<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Last week I gave a talk on <em>Purely Functional I/O</em> at Scala.io in Paris. <a href="http://blog.higher-order.com/assets/scalaio.pdf">The slides for the talk are available here.</a> In it I presented a data type for <code>IO</code> that is supposedly a &#8220;free monad&#8221;. But the monad I presented is not exactly the same as <code>scalaz.Free</code> and some people have been asking me why there is a difference and what that difference means.</p>

<h2>IO as an application of Free</h2>

<p>The <code>Free</code> monad in Scalaz is given a bit like this:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Suspend</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]]])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And throughout the methods on <code>Free</code>, it is required that <code>F</code> is a <em>functor</em> because in order to get at the recursive step inside a <code>Suspend</code>, we need to <code>map</code> over the <code>F</code> somehow.</p>

<p>But the <code>IO</code> monad I gave in the talk looks more like this:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Req</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">I</span>,<span class="kt">A</span><span class="o">](</span><span class="n">req</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">],</span> <span class="n">k</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And it could actually be stated as an application of <code>Free</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">type</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Free</span><span class="o">[({</span><span class="k">type</span> <span class="kt">Î»</span><span class="o">[</span><span class="kt">Î±</span><span class="o">]</span> <span class="kt">=</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>, <span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">Î±</span><span class="o">)</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">I</span><span class="o">}})</span><span class="k">#</span><span class="kt">Î»</span>, <span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>So in a very superficial sense, this is how the <code>IO</code> monad relates to <code>Free</code>. The monad <code>IO[F,_]</code> for a given <code>F</code> is the free monad generated by the functor <code>(F[I], I =&gt; _)</code> for some type <code>I</code>. And do note that <em>this is a functor no matter what <code>F</code> is</em>.</p>

<h2>IO as equivalent to Free</h2>

<p>There is a deeper sense in which <code>IO</code> and <code>Free</code> are actually equivalent (more precisely, isomorphic). That is, there exists a transformation from one to the other and back again. Since the only difference between <code>IO</code> and <code>Free</code> is in the functors <code>F[_]</code> vs <code>âI. (F[I], I =&gt; _)</code>, we just have to show that these two are isomorphic for any <code>F</code>.</p>

<h3>The Yoneda lemma</h3>

<p>There is an important result in category theory known as the <em>Yoneda lemma</em>. What it says is that if you have a function defined like this&#8230;</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>&#8230;then you certainly have a value of type <code>F[A]</code>. All you need is to pass the identity function to <code>map</code> in order to get the value of type <code>F[A]</code> out of this function. In fact, a function like this is in practice probably defined as a method on a value of type <code>F[A]</code> anyway. This also means that <code>F</code> is definitely a functor.</p>

<p>The Yoneda lemma says that this goes the other way around as well. If you have a value of type <code>F[A]</code> for any functor <code>F</code> and any type <code>A</code>, then you certainly have a <code>map</code> function with the signature above.</p>

<p>In scala terms, we can capture this in a type:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Yoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the Yoneda lemma says that there is an isomorphism between <code>Yoneda[F,A]</code> and <code>F[A]</code>, for any functor <code>F</code> and any type <code>A</code>. Here is the proof:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scalaz._</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">toYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Yoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">froYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">yo</span><span class="k">:</span> <span class="kt">Yoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">yo</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>CoYoneda</h3>

<p>Of course, this also means that if we have a type <code>B</code>, a function of type <code>(B =&gt; A)</code> for some type <code>A</code>, and a value of type <code>F[B]</code> for some functor <code>F</code>, then we certainly have a value of type <code>F[A]</code>. This is kind of obvious, since we can just pass the <code>B =&gt; A</code> and the <code>F[B]</code> to the <code>map</code> function for the functor and get our <code>F[A]</code>.</p>

<p>But the opposite is also true, and that is the really interesting part. If we have a value of type <code>F[A]</code>, for any <code>F</code> and <code>A</code>, then we can always destructure it into a value of type <code>F[B]</code> and a function of type <code>B =&gt; A</code>, at least for <em>some</em> type <code>B</code>. And it turns out that we can do this even if <code>F</code> is not a functor.</p>

<p>This is the permutation of the Yoneda lemma that we were using in <code>IO</code> above. That is, <code>IO[F, A]</code> is really <code>Free[({type Î»[Î±] = CoYoneda[F,Î±]})#Î», A]</code>, given:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">CoYoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">I</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">f</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the lemma says that <code>CoYoneda[F,A]</code> is isomorphic to <code>F[A]</code>. Here is the proof:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">toCoYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CoYoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">fi</span> <span class="k">=</span> <span class="n">fa</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">def</span> <span class="n">froCoYo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">A</span><span class="o">](</span><span class="n">yo</span><span class="k">:</span> <span class="kt">CoYo</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">yo</span><span class="o">.</span><span class="n">fi</span><span class="o">)(</span><span class="n">yo</span><span class="o">.</span><span class="n">f</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Of course, this destructuring into <code>CoYoneda</code> using the identity function is the simplest and most general, but there may be others for specific <code>F</code> and <code>A</code> depending on what we know about them.</p>

<p>So there you have it. The <code>scalaz.Free</code> monad with its <code>Suspend(F[Free[F,A]])</code> constructor and the <code>IO</code> monad with its <code>Req(F[I], I =&gt; IO[F,A])</code> constructor are actually equivalent. The latter is simply making use of <code>CoYoneda</code> to say the same thing.</p>

<p>Why bother? The useful part is that <code>CoYoneda[F,_]</code> is a functor for any <code>F</code>, so it&#8217;s handy to use in a free monad since we can then drop the requirement that <code>F</code> is a functor. What&#8217;s more, it gives us <em>map fusion</em> for free, since <code>map</code> over <code>CoYoneda</code> is literally just function composition on its <code>f</code> component. Although this latter is, in the absence of tail call elimination, not as useful as it could be in Scala.</p>

<p>I hope that sheds a little bit of light on the Yoneda lemma as well as the different embeddings of free monads.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/20/free-monads-and-free-monoids/">Free Monoids and Free Monads</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-20T00:00:00-04:00" pubdate data-updated="true">Aug 20<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In a series of old posts, I once talked about the link between <a href="http://apocalisp.wordpress.com/2010/06/14/on-monoids/">lists and monoids</a>, as well as <a href="http://apocalisp.wordpress.com/2010/07/21/more-on-monoids-and-monads/">monoids and monads</a>. Now I want to talk a little bit more about monoids and monads from the perspective of <em>free structures</em>.</p>

<p><code>List</code> is a <em>free monoid</em>. That is, for any given type <code>A</code>, <code>List[A]</code> is a monoid, with list concatenation as the operation and the empty list as the identity element.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">freeMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span> <span class="k">=</span> <span class="nc">Nil</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">op</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">a1</span> <span class="o">++</span> <span class="n">a2</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Being a free monoid means that it&#8217;s the <em>minimal</em> such structure. <code>List[A]</code> has exactly enough structure so that it is a monoid for any given <code>A</code>, and it has no further structure. This also means that for any given monoid <code>B</code>, there must exist a transformation, a <em>monoid homomorphism</em> from <code>List[A]</code> to <code>B</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>Given a mapping from <code>A</code> to a monoid <code>B</code>, we can collapse a value in the monoid <code>List[A]</code> to a value in <code>B</code>.</p>

<h2>Free monads</h2>

<p>Now, if you followed my old posts, you already know that monads are &#8220;higher-kinded monoids&#8221;. A monoid in a category where the objects are type constructors (functors, actually) and the arrows between them are natural transformations. As a reminder, a natural transformation from <code>F</code> to <code>G</code> can be represented this way in Scala:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">~&gt;</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And it turns out that there is a free monad for any given functor <code>F</code>:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">Return</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Suspend</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]])</span> <span class="k">extends</span> <span class="nc">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Analogous to how a <code>List[A]</code> is either <code>Nil</code> (the empty list) or a product of a <code>head</code> element and <code>tail</code> list, a value of type <code>Free[F,A]</code> is either an <code>A</code> or a product of <code>F[_]</code> and <code>Free[F,_]</code>. It is a recursive structure. And indeed, it has <em>exactly enough structure</em> to be a monad, for any given <code>F</code>, and no more.</p>

<p>When I say &#8220;product&#8221; of two functors like <code>F[_]</code> and <code>Free[F,_]</code>, I mean a product like this:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">:*:</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">type</span> <span class="kt">Î»</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we might expect that there is a <em>monad homomorphism</em> from a free monad on <code>F</code> to any monad that <code>F</code> can be transformed to. And indeed, it turns out that there is. The free monad catamorphism is in fact a monad homomorphism. Given a natural transformation from <code>F</code> to <code>G</code>, we can collapse a <code>Free[F,A]</code> to <code>G[A]</code>, just like with <code>foldMap</code> when given a function from <code>A</code> to <code>B</code> we could collapse a <code>List[A]</code> to <code>B</code>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">runFree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Monad</span>,<span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>But what&#8217;s the equivalent of <code>foldRight</code> for <code>Free</code>? Remember, foldRight takes a unit element <code>z</code> and a function that accumulates into <code>B</code> so that <code>B</code> doesn&#8217;t actually have to be a monoid. Here, <code>f</code> is a lot like the monoid operation, except it takes the current <code>A</code> on the left:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldRight</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>The equivalent for <code>Free</code> takes a natural transformation as its unit element, which for a monad happens to be monadic <code>unit</code>. Then it takes a natural transformation as its <code>f</code> argument, that looks a lot like monadic <code>join</code>, except it takes the current <code>F</code> on the left:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">type</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">A</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">foldFree</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:Functor</span>,<span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>,<span class="kt">A</span><span class="o">](</span>
</span><span class='line'>  <span class="n">as</span><span class="k">:</span> <span class="kt">Free</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">A</span><span class="o">])(</span>
</span><span class='line'>  <span class="n">z</span><span class="k">:</span> <span class="kt">Id</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)(</span>
</span><span class='line'>  <span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">F:*:G</span><span class="o">)</span><span class="k">#</span><span class="kt">Î»</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this case, <code>G</code> does not have to be a monad at all.</p>

<p><code>Free</code> as well as natural transformations and product types are available in <a href="http://github.com/scalaz">Scalaz</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/26/machines/">Machines and Stream Processing</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-26T12:34:00-05:00" pubdate data-updated="true">Jan 26<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I gave a talk on &#8220;Machines&#8221; and stream processing in <a href="https://github.com/ekmett/machines">Haskell</a> and <a href="https://github.com/runarorama/scala-machines">Scala</a>, to the <a href="http://www.bfpg.org/">Brisbane Functional Programming Group</a> at Microsoft HQ in December 2012. A lot of people have asked me for the slides, so here they are:</p>

<p><a href="https://dl.dropbox.com/u/4588997/Machines.pdf">Machines.pdf</a></p>

<p>The preÃ«mptive answer to the usual follow-up question is that the talk was not recorded.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/13/what-purity-is-and-isnt/">What Purity Is and Isn&#8217;t</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-13T22:07:00-04:00" pubdate data-updated="true">Sep 13<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>A lot of discussion about &#8220;purity&#8221; goes on without participants necessarily having a clear idea of what it means exactly. Such discussion is generally unhelpful and distracting.</p>

<h3>What purity is</h3>

<p>The typical definition of purity (and the one we use in <a href="http://manning.com/bjarnason">our book</a>) goes something like this:</p>

<p>An expression <code>e</code> is <em>referentially transparent</em> if for all programs <code>p</code>, every occurrence of <code>e</code> in <code>p</code> can be replaced with the result of evaluating <code>e</code> without changing the result of evaluating <code>p</code>.</p>

<p>A function <code>f</code> is <em>pure</em> if the expression <code>f(x)</code> is referentially transparent for all referentially transparent <code>x</code>.</p>

<p>Now, something needs to be made clear right up front. Like all definitions, this holds in a specific <em>context</em>. In particular, the context needs to specify what &#8220;evaluating&#8221; means. It also needs to define &#8220;program&#8221;, &#8220;occurrence&#8221;, and the semantics of &#8220;replacing&#8221; one thing with another.</p>

<p>In a programming language like Haskell, Java, or Scala, this context is pretty well established. The process of evaluation is a reduction to some <em>normal form</em> such as weak head or beta normal form.</p>

<h3>A simple example</h3>

<p>To illustrate, let&#8217;s consider programs in an exceedingly simple language that we will call <em>Sigma</em>. An expression in Sigma has one of the following forms:</p>

<ul>
<li>A literal character string like <code>"a"</code>, <code>"foo"</code>, <code>""</code>, etc.</li>
<li>A concatenation, <code>s + t</code>, for expressions <code>s</code> and <code>t</code>.</li>
<li>A special <code>Ext</code> expression that denotes input from an external source.</li>
</ul>


<p>Now, without an evaluator for Sigma, it is a purely abstract algebra. So let&#8217;s define a straigtforward evaluator <code>eval</code> for it, with the following rules:</p>

<ul>
<li>A literal string is already in normal form.</li>
<li><code>eval(s + t)</code> first evaluates <code>s</code> and <code>t</code> and concatenates the results into one literal string.</li>
<li><code>eval(Ext)</code> reads a line from standard input and returns it as a literal string.</li>
</ul>


<p>This might seem very simple, but it is still not clear whether <code>Ext</code> is referentially transparent with regard to <code>eval</code>. It depends. What does &#8220;reads a line&#8221; mean, and what is &#8220;standard input&#8221; exactly? This is all part of a context that needs to be established.</p>

<p>Here&#8217;s one implementation of an evaluator for Sigma, in Scala:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">,</span> <span class="n">t</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Ext</span> <span class="k">extends</span> <span class="nc">Sigma</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">eval1</span><span class="o">(</span><span class="n">sig</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sigma</span> <span class="o">=</span> <span class="n">sig</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Ext</span> <span class="k">=&gt;</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">readLine</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, it&#8217;s easy to see that the <code>Ext</code> instruction is <em>not</em> referentially transparent with regard to <code>eval1</code>. Replacing <code>Ext</code> with <code>eval1(ext)</code> does not preserve meaning. Consider this:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Ext</span>
</span><span class='line'><span class="n">eval1</span><span class="o">(</span><span class="nc">Concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>VS this:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">eval1</span><span class="o">(</span><span class="nc">Ext</span><span class="o">)</span>
</span><span class='line'><span class="n">eval1</span><span class="o">(</span><span class="nc">Concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&#8217;s clearly not the same thing. The former will get two strings from standard input and concatenate them together. The latter will get only one string, store it as <code>x</code>, and return <code>x + x</code>.</p>

<p>Now consider a slightly different evaluator:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">eval2</span><span class="o">(</span><span class="n">sig</span><span class="k">:</span> <span class="kt">Sigma</span><span class="o">,</span> <span class="n">stdin</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sigma</span> <span class="o">=</span> <span class="n">sig</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Concat</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval2</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">e2</span><span class="o">)</span> <span class="k">=</span> <span class="n">eval2</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">Lit</span><span class="o">(</span><span class="n">e1</span> <span class="o">+</span> <span class="n">e2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Ext</span> <span class="k">=&gt;</span> <span class="nc">Lit</span><span class="o">(</span><span class="n">stdin</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this case, the <code>Ext</code> instruction clearly <em>is</em> referentially transparent with regard to <code>eval2</code>, because our standard input is just a string, and it is always the same string. So you see, the purity of functions in the Sigma language very much depends on how that language is interpreted.</p>

<p>This is the reason why Haskell programs are considered &#8220;pure&#8221;, even in the presence of <code>IO</code>. A value of type <code>IO a</code> in Haskell is simply a function. Reducing it to normal form (evaluating it) has no effect. An <code>IO</code> action is of course not referentially transparent with regard to <code>unsafePerformIO</code>, but as long as your program does not use that it remains a referentially transparent expression.</p>

<h3>What purity is not</h3>

<p>In my experience there are more or less two camps into which unhelpful views on purity fall.</p>

<p>The first view, which we will call the <em>empiricist</em> view, is typically taken by people who understand &#8220;pure&#8221; as a pretentious term, meant to denegrate regular everyday programming as being somehow &#8220;impure&#8221; or &#8220;unclean&#8221;. They see purity as being &#8220;academic&#8221;, detached from reality, in an ivory tower, or the like.</p>

<p>This view is premised on a superficial understanding of purity. The assumption is that purity is somehow about the absence of I/O, or not mutating memory. But how could any programs be written that don&#8217;t change the state of memory? At the end of the day, you have to update the CPU&#8217;s registers, write to memory, and produce output on a display. A program has to make the computer <em>do something</em>, right? So aren&#8217;t we just pretending that our programs don&#8217;t run on real computers? Isn&#8217;t it all just an academic exercise in making the CPU warm?</p>

<p>Well, no. That&#8217;s not what purity means. Purity is not about the absence of program behaviors like I/O or mutable memory. It&#8217;s about delimiting such behavior in a specific way.</p>

<p>The other view, which I will call the <em>rationalist</em> view, is typically taken by people with overexposure to modern analytic philosophy. Expressions are to be understood by their <em>denotation</em>, not by reference to any evaluator. Then of course every expression is really referentially transparent, and so purity is a distinction without a difference. After all, an imperative side-effectful C program can have the same denotation as a monadic, side-effect-free Haskell program. There is nothing wrong with this viewpoint, but it&#8217;s not instructive <em>in this context</em>. Sure, when designing in the abstract, we can think denotationally without regard to evaluation. But when concretizing the design in terms of an actual programming language, we do need to be aware of how we expect evaluation to take place. And only then are referential transparency and purity useful concepts.</p>

<p>Both of these, the rationalist and empiricist views, conflate different levels of abstraction. A program written in a programming language is not the same thing as the physical machine that it may run on. Nor is it the same thing as the abstractions that capture its meaning.</p>

<h3>Further reading</h3>

<p>I highly recommend the paper <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;sqi=2&amp;ved=0CCMQFjAB&amp;url=http%3A%2F%2Fwww.cs.indiana.edu%2F~sabry%2Fpapers%2FpurelyFunctional.ps&amp;ei=I5NYUIRUqvXSAbC_gKgF&amp;usg=AFQjCNGwxjzB5zUBws6D9wnKPzo-zL57pw&amp;sig2=HgE-ZhzoIS19TEe2K2EW-Q"><em>What is a Purely Functional Language?</em></a> by Amr Sabry, although it deals with the idea of a <em>purely functional language</em> rather than purity of functions within a language that does not meet that criteria.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/04/this-blog-has-moved/">New Beginnings</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-09-04T01:29:00-04:00" pubdate data-updated="true">Sep 4<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I have not seriously updated the <a href="http://apocalisp.wordpress.com">old Apocalisp blog</a> for quite some time. Mostly this is due to the fact that I have been spending all of my creative time outside of work on <a href="http://manning.com/bjarnason">writing a book</a>. It&#8217;s also partly that putting a post up on WordPress is a chore. It&#8217;s like building a ship in a bottle.</p>

<p>So I have decided to make posting really easy for myself by hosting the blog <a href="http://github.com/runarorama/runarorama.github.com">on GitHub</a>. I am using a dead-simple markdown-based framework called <a href="http://octopress.org">Octopress</a>. With this setup I can very easily write a new post from my command line and publish by pushing to GitHub. This is already part of my normal coding workflow, so it feels more friction-free.</p>

<p>The new blog is simply titled &#8220;Higher Order&#8221;, and is available at <a href="http://blog.higher-order.com">blog.higher-order.com</a>. Check back soon for posts that I&#8217;ve been sitting on but have been too <del>lazy</del> busy to post.</p>

<p>All of the old content and comments will still be available at the old address, and I&#8217;ll probably cross-post to both places for a little while.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/14/scalaz-tutorial-enumeration-based-io-with-iteratees/">Scalaz Tutorial: Enumeration-based I/O With Iteratees</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-14T00:00:00-04:00" pubdate data-updated="true">Oct 14<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://scalaz.org">Scalaz</a> 5.0 adds an implementation of a concept called Iteratee. This is a highly flexible programming technique for writing enumeration-based input processors that can be freely composed.</p>

<p>A lot of people have asked me to write a tutorial on how this works, specifically on how it is implemented in Scalaz and how to be productive with it, so here we go.</p>

<p>The implementation in Scalaz is based on an excellent article by John W. Lato called <a href="http://themonadreader.files.wordpress.com/2010/05/issue16.pdf">âIteratee: Teaching an Old Fold New Tricksâ</a>. As a consequence, this post is also based on that article, and because I am too unoriginal to come up with my own examples, the examples are directly translated from it. The article gives code examples in Haskell, but we will use Scala here throughout.</p>

<h2>Motivation</h2>

<p>Most programmers have come across the problem of treating an I/O data source (such as a file or a socket) as a data structure. This is a common thing to want to do. To contrast, the usual means of reading, say, a file, is to open it, get a cursor into the file (such as a FileReader or an InputStream), and read the contents of the file as it is being processed. You must of course handle IO exceptions and remember to close the file when you are done. The problem with this approach is that it is not modular. Functions written in this way are performing one-off side-effects. And as we know, side-effects do not compose.</p>

<p>Treating the stream of inputs as an enumeration is therefore desirable. It at least holds the lure of modularity, since we would be able to treat a File, from which weâre reading values, in the same way that we would treat an ordinary List of values, for example.</p>

<p>A naive approach to this is to use iterators, or rather, Iterables. This is akin to the way that you would typically read a file in something like Ruby or Python. Basically you treat it as a collection of Strings:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">getContents</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">fr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">fileName</span><span class="o">))</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">iterator</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">hasNext</span> <span class="k">=</span> <span class="n">line</span> <span class="o">!=</span> <span class="kc">null</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">next</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">retVal</span> <span class="k">=</span> <span class="n">line</span>
</span><span class='line'>        <span class="n">line</span> <span class="k">=</span> <span class="n">getLine</span>
</span><span class='line'>        <span class="n">retVal</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">getLine</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="n">line</span><span class="k">:</span><span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">line</span> <span class="k">=</span> <span class="n">fr</span><span class="o">.</span><span class="n">readLine</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">line</span> <span class="k">=</span> <span class="kc">null</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">line</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="n">getLine</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>What this is doing is a kind of lazy I/O. Nothing is read from the file until it is requested, and we only hold one line in memory at a time. But there are some serious issues with this approach. Itâs not clear when you should close the file handle, or whose responsibility that is. You could have the Iterator close the file when it has read the last line, but what if you only want to read part of the file? Clearly this approach is not sufficient. There are some things we can do to make this more sophisticated, but only at the expense of breaking the illusion that the file really is a collection of Strings.</p>

<h2>The Idea</h2>

<p>Any red-blooded functional programmer should be thinking right about now: âInstead of getting Strings out of the file, just pass in a function that will serve as a handler for each new line!â Bingo. This is in fact the plot with Iteratees. Instead of implementing an interface from which we request Strings by pulling, weâre going to give an implementation of an interface that can receive Strings by pushing.</p>

<p>And indeed, this idea is nothing new. This is exactly what we do when we fold a list:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">foldLeft</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>The second argument is exactly that, a handler for each element in the list, along with a means of combining it with the accumulated value so far.</p>

<p>Now, there are two issues with an ordinary fold that prevent it from being useful when enumerating file contents. Firstly, there is no way of indicating that the fold should stop early. Secondly, a list is held all in memory at the same time.</p>

<h2>The Iteratee Solution</h2>

<p>Scalaz defines the following two data structures (actual implementation may differ, but this serves for illustration):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">+E</span><span class="o">]</span>
</span><span class='line'><span class="nc">case</span> <span class="k">class</span> <span class="nc">El</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">EOF</span> <span class="k">extends</span> <span class="nc">Input</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">run</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// Implementation omitted</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Done</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cont</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">k</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>So an input to an iteratee is represented by Input[E], where E is the element type of the input source. It can be either an element (the next element in the file or stream), or itâs one of two signals: Empty or EOF. The Empty signal tells the iteratee that there is not an element available, but to expect more elements later. The EOF signal tells the iteratee that there are no more elements to be had.</p>

<p>Note that this particular set of signals is kind of arbitrary. It just facilitates a particular set of use cases. Thereâs no reason you couldnât have other signals for other use cases. For example, a signal I can think of off the top of my head would be Restart, which would tell the iteratee to start its result from scratch at the current position in the input.</p>

<p>IterV[E,A] represents a computation that can be in one of two states. It can be Done, in which case it will hold a result (the accumulated value) of type A. Or it can be waiting for more input of type E, in which case it will hold a continuation that accepts the next input.</p>

<p>Letâs see how we would use this to process a List. The following function takes a list and an iteratee and feeds the listâs elements to the iteratee.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">enumerate</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">E</span><span class="o">],</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">i</span><span class="nd">@Done</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">i</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs</span><span class="o">,</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">enumerate</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">k</span><span class="o">(</span><span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now letâs see some actual iteratees. As a simple example, here is an iteratee that counts the number of elements it has seen:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">counter</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And hereâs an iteratee that discards the first n elements:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">drop</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">A</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">drop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">((),</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Done</span><span class="o">((),</span> <span class="nc">Empty</span><span class="o">)</span> <span class="k">else</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And one that takes the first element from the input:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">head</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Input</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">El</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Empty</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">EOF</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">EOF</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="nc">Cont</span><span class="o">(</span><span class="n">step</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Letâs go through this code. Each one defines a âstepâ function, which is the function that will handle the next input. Each one starts the iteratee in the Cont state, and the step function always returns a new iteratee in the next state based on the input received. Note in the last one (head), we are using the Empty signal to indicate that we want to remove the element from the input. The utility of this will be clear when we start composing iteratees.</p>

<p>Now, an example usage. To get the length of a list, we write:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">enumerate</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="n">counter</span><span class="o">[</span><span class="kt">Int</span><span class="o">]).</span><span class="n">run</span> <span class="c1">// 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>The run method on IterV just gets the accumulated value out of the Done iteratee. If it isnât done, it sends the EOF signal to itself first and then gets the value.</p>

<h2>Composing Iteratees</h2>

<p>Notice a couple of things here. With iteratees, the input source can send the signal that it has finished producing values. And on the other side, the iteratee itself can signal to the input source that it has finished consuming values. So on one hand, we can leave an iteratee ârunningâ by not sending it the EOF signal, so we can compose two input sources and feed them into the same iteratee. On the other hand, an iteratee can signal that itâs done, at which point we can start sending any remaining elements to another iteratee. In other words, iteratees compose sequentially.</p>

<p>In fact, IterV[E,A] is an instance of the Monad type class for each fixed E, and composition is very similar to the way monadic parsers compose:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IterV</span><span class="o">[</span><span class="kt">E</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Done</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Done</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Done</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Cont</span><span class="o">(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="n">flatMap</span> <span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here then is an example of composing iteratees with a for-comprehension:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">drop1Keep1</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">drop</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">head</span>
</span><span class='line'><span class="o">}</span> <span class="k">yield</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>The iteratee above discards the first element it sees and returns the second one. The iteratee below does this n times, accumulating the kept elements into a list.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">alternates</span><span class="o">[</span><span class="kt">E</span><span class="o">](</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">drop1Keep1</span><span class="o">[</span><span class="kt">E</span><span class="o">].</span>
</span><span class='line'>    <span class="n">replicate</span><span class="o">[</span><span class="kt">List</span><span class="o">](</span><span class="n">n</span><span class="o">).</span>
</span><span class='line'>    <span class="n">foldRight</span><span class="o">(</span><span class="nc">Done</span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">E</span><span class="o">]](),</span><span class="nc">Empty</span><span class="o">))((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">h</span> <span class="k">&lt;-</span> <span class="n">x</span>
</span><span class='line'>      <span class="n">t</span> <span class="k">&lt;-</span> <span class="n">y</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">flatten</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Hereâs an example run:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala> enumerate(List.range(1,15), alternates[Int](5)).run
</span><span class='line'>res85: List[Int] = List(2, 4, 6, 8, 10)</span></code></pre></td></tr></table></div></figure>


<h2>File Input With Iteratees</h2>

<p>Using the iteratees to read from file input turns out to be incredibly easy. The only difference is in how the data source is enumerated, and in order to remain lazy (and not prematurely perform any side-effects), we must return our iteratee in a monad:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">enumReader</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">BufferedReader</span><span class="o">,</span>
</span><span class='line'>                  <span class="n">it</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">loop</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">i</span><span class="nd">@Done</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">i</span> <span class="o">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">i</span><span class="nd">@Cont</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">s</span> <span class="k">&lt;-</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">r</span><span class="o">.</span><span class="n">readLine</span> <span class="o">}</span>
</span><span class='line'>      <span class="n">a</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="nc">IO</span> <span class="o">{</span> <span class="n">i</span> <span class="o">}</span> <span class="k">else</span> <span class="n">loop</span><span class="o">(</span><span class="n">k</span><span class="o">(</span><span class="nc">El</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="n">loop</span><span class="o">(</span><span class="n">it</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The monad being used here is an IO monad that Iâll explain in a second. The important thing to note is that the iteratee is completely oblivious to the fact that itâs being fed lines from a BufferedReader rather than a List.</p>

<p>Here is the IO monad Iâm using. As you can see, itâs really just a lazy identity monad:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">io</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">sealed</span> <span class="k">trait</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">unsafePerformIO</span><span class="k">:</span> <span class="kt">A</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">object</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">unsafePerformIO</span> <span class="k">=</span> <span class="n">a</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">IOMonad</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">IO</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">pure</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">implicitly</span><span class="o">[</span><span class="kt">Monad</span><span class="o">[</span><span class="kt">Function0</span><span class="o">]].</span><span class="n">bind</span><span class="o">(</span>
</span><span class='line'>        <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">unsafePerformIO</span><span class="o">,</span>
</span><span class='line'>        <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">).</span><span class="n">unsafePerformIO</span><span class="o">)()</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>To read lines from a file, weâll do something like this:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">bufferFile</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">closeReader</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Reader</span><span class="o">)</span> <span class="k">=</span> <span class="nc">IO</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">r</span><span class="o">.</span><span class="n">close</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">bracket</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
</span><span class='line'>                   <span class="n">fin</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span>
</span><span class='line'>                   <span class="n">body</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'><span class="k">for</span> <span class="o">{</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">init</span>
</span><span class='line'>      <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">body</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">fin</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>  <span class="k">yield</span> <span class="n">c</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">enumFile</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">IterV</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">bracket</span><span class="o">(</span><span class="n">bufferFile</span><span class="o">(</span><span class="n">f</span><span class="o">),</span>
</span><span class='line'>          <span class="n">closeReader</span><span class="o">(</span><span class="k">_:</span><span class="kt">BufferedReader</span><span class="o">),</span>
</span><span class='line'>          <span class="n">enumReader</span><span class="o">(</span><span class="k">_:</span><span class="kt">BufferedReader</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The enumFile method uses bracketing to ensure that the file always gets closed. Itâs completely lazy though, so nothing actually happens until you call unsafePerformIO on the resulting IO action:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>scala> enumFile(new File("/Users/runar/Documents/Iteratees.txt"), head) map (_.run)                
</span><span class='line'>res2: io.IO[Option[String]] = io$IO@5f90b584
</span><span class='line'>
</span><span class='line'>scala> res2.unsafePerformIO
</span><span class='line'>res3: Option[String] = Some(Scalaz Tutorial: Enumeration-Based I/O With Iteratees)</span></code></pre></td></tr></table></div></figure>


<p>That uses the âheadâ iteratee from above to get the first line of the file that Iâm using to edit this blog post.</p>

<p>We can get the number of lines in two files combined, by composing two enumerations and using our âcounterâ iteratee from above:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">lengthOfTwoFiles</span><span class="o">(</span><span class="n">f1</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">f2</span><span class="k">:</span> <span class="kt">File</span><span class="o">)</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">l1</span> <span class="k">&lt;-</span> <span class="n">enumFile</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">counter</span><span class="o">)</span>
</span><span class='line'>  <span class="n">l2</span> <span class="k">&lt;-</span> <span class="n">enumFile</span><span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">l1</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span> <span class="k">yield</span> <span class="n">l2</span><span class="o">.</span><span class="n">run</span>
</span></code></pre></td></tr></table></div></figure>


<p>So what we have here is a uniform and compositional interface for enumerating both pure and effectful data sources. We can avoid holding on to the entire input in memory when we donât want to, and we have complete control over when to stop iterating. The iteratee can decide whether to consume elements, leave them intact, or even truncate the input. The enumerator can decide whether to shut the iteratee down by sending it the EOF signal, or to leave it open for other enumerators.</p>

<p>There is even more to this approach, as we can use iteratees not just to read from data sources, but also to write to them. That will have to await another post.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
<h1>Read my book</h1>
<a href="http://manning.com/bjarnason"><img src="/images/FPinScala-5A.png" width="553px" height="694px"></a>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/03/19/monoid-morphisms-products-coproducts/">Monoid morphisms, products, and coproducts</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/01/free-and-yoneda/">Free monads and the Yoneda lemma</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/20/free-monads-and-free-monoids/">Free monoids and free monads</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/26/machines/">Machines and stream processing</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/13/what-purity-is-and-isnt/">What purity is and isn&#8217;t</a>
      </li>
    
  </ul>
</section>
<section>
<h1>Advertisements</h1>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-6768669929440333";
/* blog.higher-order.com */
google_ad_slot = "2670487594";
google_ad_width = 160;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</section>

<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("runarorama", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/runarorama" class="twitter-follow-button" data-show-count="false">Follow @runarorama</a>
  
</section>


<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/runarorama">@runarorama</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'runarorama',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/runarorama?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - RÃºnar Bjarnason -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
