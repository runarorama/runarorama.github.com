
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Monoid Morphisms, Products, and Coproducts - Higher Order</title>
  <meta name="author" content="RÃºnar Bjarnason">

  
  <meta name="description" content="Today I want to talk about relationships between monoids. These can be useful to think about when we&rsquo;re developing libraries involving monoids &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://runarorama.github.com/blog/2014/03/19/monoid-morphisms-products-coproducts/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Higher Order" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script type="text/javascript" src="//use.typekit.net/fbs7fzv.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34544663-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  <link href="/stylesheets/datatable.css" media="screen, projection" rel="stylesheet" type="text/css" />
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Higher Order</a></h1>
  
    <h2>Philosophy and functional programming.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="runarorama.github.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Monoid Morphisms, Products, and Coproducts</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-03-19'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Today I want to talk about relationships between monoids. These can be useful to think about when we&rsquo;re developing libraries involving monoids, and we want to express some algebraic laws among them. We can then check these with automated tests, or indeed <em>prove</em> them with algebraic reasoning.</p>

<p>This post kind of fell together when writing notes on chapter 10, &ldquo;Monoids&rdquo;, of <a href="http://manning.com/bjarnason">Functional Programming in Scala</a>. I am putting it here so I can reference it from the chapter notes at the end of the book.</p>

<h2>Monoid homomorphisms</h2>

<p>Let&rsquo;s take the <code>String</code> concatenation and <code>Int</code> addition as example monoids that have a relationship. Note that if we take the length of two strings and add them up, this is the same as concatenating those two strings and taking the length of the combined string:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">).</span><span class="n">length</span>
</span></code></pre></td></tr></table></div></figure>


<p>So every <code>String</code> maps to a corresponding <code>Int</code> (its length), and every concatenation of strings maps to the addition of corresponding lengths.</p>

<p>The <code>length</code> function maps from <code>String</code> to <code>Int</code> <em>while preserving the monoid structure</em>. Such a function, that maps from one monoid to another in such a preserving way, is called a <em>monoid homomorphism</em>. In general, for monoids <code>M</code> and <code>N</code>, a homomorphism <code>f: M =&gt; N</code>, and all values <code>x:M</code>, <code>y:M</code>, the following equations hold:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">f</span><span class="o">(</span><span class="n">x</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">f</span><span class="o">(</span><span class="n">y</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="n">f</span><span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">M</span><span class="o">])</span> <span class="o">==</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">N</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>|+|</code> syntax is from <a href="http://github.com/scalaz/scalaz">Scalaz</a> and is obtained by importing <code>scalaz.syntax.monoid._</code>. It just references the <code>append</code> method on the <code>Monoid[T]</code> instance, where <code>T</code> is the type of the arguments. The <code>mzero[T]</code> function is also from that same import and references <code>zero</code> in <code>Monoid[T]</code>.</p>

<p>This <em>homomorphism law</em> can have real practical benefits. Imagine for example a &ldquo;result set&rdquo; monoid that tracks the locations of a particular set of records in a database or file. This could be as simple as a <code>Set</code> of locations. Concatenating several thousand files and then proceeding to search through them is going to be much slower than searching through the files individually and then concatenating the result sets. Particularly since we can potentially search the files in parallel. A good automated test for our result set monoid would be that it admits a homomorphism from the data file monoid.</p>

<h2>Monoid isomorphisms</h2>

<p>Sometimes there will be a homomorphism in both directions between two monoids. If these are inverses of one another, then this kind of relationship is called a <em>monoid isomorphism</em> and we say that the two monoids are isomorphic. More precisely, we will have two monoids <code>A</code> and <code>B</code>, and homomorphisms <code>f: A =&gt; B</code> and <code>g: B =&gt; A</code>. If <code>f(g(b)) == b</code> and <code>g(f(a)) == a</code>, for all <code>a:A</code> and <code>b:B</code> then <code>f</code> and <code>g</code> form an isomorphism.</p>

<p>For example, the <code>String</code> and <code>List[Char]</code> monoids with concatenation are isomorphic. We can convert a <code>String</code> to a <code>List[Char]</code>, preserving the monoid structure, and go back again to the exact same <code>String</code> we started with. This is also true in the inverse direction, so the isomorphism holds.</p>

<p>Other examples include (<code>Boolean</code>, <code>&amp;&amp;</code>) and (<code>Boolean</code>, <code>||</code>) which are isomorphic via <code>not</code>.</p>

<p>Note that there are monoids with homomorphisms in both directions between them that nevertheless are <em>not</em> isomorphic. For example, (<code>Int</code>, <code>*</code>) and (<code>Int</code>, <code>+</code>). These are homomorphic to one another, but not isomorphic (thanks, Robbie Gates).</p>

<h2>Monoid products and coproducts</h2>

<p>If <code>A</code> and <code>B</code> are monoids, then <code>(A,B)</code> is certainly a monoid, called their <em>product</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">product</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Monoid</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">),</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span> <span class="k">=</span>
</span><span class='line'>      <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">_1</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_2</span> <span class="o">|+|</span> <span class="n">y</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">zero</span> <span class="k">=</span> <span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But is there such a thing as a monoid <em>coproduct</em>? Could we just use <code>Either[A,B]</code> for monoids <code>A</code> and <code>B</code>? What would be the <code>zero</code> of such a monoid? And what would be the value of <code>Left(a) |+| Right(b)</code>? We could certainly choose an arbitrary rule, and we may even be able to satisfy the monoid laws, but would that mean we have a <em>monoid coproduct</em>?</p>

<p>To answer this, we need to know the precise meaning of <em>product</em> and <em>coproduct</em>. These come straight from Wikipedia, with a little help from Cale Gibbard.</p>

<p>A <em>product</em> <code>M</code> of two monoids <code>A</code> and <code>B</code> is a monoid such that there exist homomorphisms <code>fst: M =&gt; A</code>, <code>snd: M =&gt; B</code>, and for any monoid <code>Z</code> and morphisms <code>f: Z =&gt; A</code> and <code>g: Z =&gt; B</code> there has to be a unique homomorphism <code>h: Z =&gt; M</code> such that <code>fst(h(z)) == f(z)</code> and <code>snd(h(z)) == g(z)</code> for all <code>z:Z</code>. In other words, the following diagram must commute:</p>

<p><img src="/images/Product.png"></p>

<p>A <em>coproduct</em> <code>W</code> of two monoids <code>A</code> and <code>B</code> is the same except the arrows are reversed. It&rsquo;s a monoid such that there exist homomorphisms <code>left: A =&gt; W</code>, <code>right: B =&gt; W</code>, and for any monoid <code>Z</code> and morphisms <code>f: A =&gt; Z</code> and <code>g: B =&gt; Z</code> there has to be a unique homomorphism <code>h: W =&gt; Z</code> such that <code>h(left(a)) == f(a)</code> and <code>h(right(b)) == g(b)</code> for all <code>a:A</code> and all <code>b:B</code>. In other words, the following diagram must commute:</p>

<p><img src="/images/Coproduct.png"></p>

<p>We can easily show that our <code>productMonoid</code> above really is a monoid product. The homomorphisms are the methods <code>_1</code> and <code>_2</code> on <code>Tuple2</code>. They simply map every element of <code>(A,B)</code> to a corresponding element in <code>A</code> and <code>B</code>. The monoid structure is preserved because:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">p</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">).</span><span class="n">_1</span> <span class="o">==</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_1</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'><span class="o">(</span><span class="n">p</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">).</span><span class="n">_2</span> <span class="o">==</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">_2</span> <span class="o">|+|</span> <span class="n">q</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">zero</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)].</span><span class="n">_1</span> <span class="o">==</span> <span class="n">zero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="n">zero</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)].</span><span class="n">_2</span> <span class="o">==</span> <span class="n">zero</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And for any other monoid <code>Z</code>, and morphisms <code>f: Z =&gt; A</code> and <code>g: Z =&gt; B</code>, we can construct a unique morphism from <code>Z</code> to <code>(A,B)</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">factor</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">Z</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>  <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">z</span><span class="o">),</span> <span class="n">g</span><span class="o">(</span><span class="n">z</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And this really is a homomorphism because we just inherit the homomorphism law from <code>f</code> and <code>g</code>.</p>

<p>What does a coproduct then look like? Well, it&rsquo;s going to be a type <code>C[A,B]</code> together with an instance <code>coproduct[A:Monoid,B:Monoid]:Monoid[C[A,B]]</code>. It will be equipped with two monoid homomorphisms, <code>left: A =&gt; C[A,B]</code> and <code>right: B =&gt; C[A,B]</code> that satisfy the following (according to the monoid homomorphism law):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">left</span><span class="o">(</span><span class="n">a1</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">left</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span> <span class="o">==</span> <span class="n">left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span>
</span><span class='line'><span class="o">(</span><span class="n">right</span><span class="o">(</span><span class="n">b1</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">right</span><span class="o">(</span><span class="n">b2</span><span class="o">))</span> <span class="o">==</span> <span class="n">right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">left</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">==</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]</span>
</span><span class='line'><span class="n">right</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="o">==</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>And additionally, for any other monoid <code>Z</code> and homomorphisms <code>f: A =&gt; Z</code> and <code>g: B =&gt; Z</code> we must be able to construct a unique homomorphism from <code>C[A,B]</code> to <code>Z</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
</span></code></pre></td></tr></table></div></figure>


<p>Right off the bat, we know some things that <em>definitely won&rsquo;t work</em>. Just using <code>Either</code> is a non-starter because there&rsquo;s no well-defined <code>zero</code> for it, and there&rsquo;s no way of appending a <code>Left</code> to a <code>Right</code>. But what if we just added that structure?</p>

<h3>Free monoids on coproducts</h3>

<p>The underlying set of a monoid <code>A</code> is just the type <code>A</code> without the monoid structure. The coproduct of types <code>A</code> and <code>B</code> is the type <code>Either[A,B]</code>. Having &ldquo;forgotten&rdquo; the monoid structure of both <code>A</code> and <code>B</code>, we can recover it by generating a free monoid on <code>Either[A,B]</code>, which is just <code>List[Either[A,B]]</code>. The <code>append</code> operation of this monoid is list concatenation, and the identity for it is the empty list.</p>

<p>Clearly <code>List[Either[A,B]]</code> is a monoid, but does it permit a homomorphism from both monoids <code>A</code> and <code>B</code>? If so, then the following properties should hold:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">))</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">))</span>
</span><span class='line'><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">))</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>They clearly do not hold! The lists on the left of <code>==</code> will have two elements and the lists on the right will have one element. Can we do something about this?</p>

<p>Well, the fact is that <code>List[Either[A,B]]</code> is not exactly the monoid coproduct of <code>A</code> and <code>B</code>. It&rsquo;s still &ldquo;too big&rdquo;. The problem is again that we can observe the internal structure of expressions.</p>

<p>What we need is not exactly the <code>List</code> monoid, but a new monoid called the <em>free monoid product</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">class</span> <span class="nc">Eithers</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span>
</span><span class='line'>  <span class="k">private</span> <span class="k">val</span> <span class="n">toList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]])</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="o">++(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>      <span class="nc">Eithers</span><span class="o">(</span><span class="n">toList</span> <span class="o">++</span> <span class="n">p</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z:Monoid</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
</span><span class='line'>      <span class="n">toList</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">Z</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">z</span>
</span><span class='line'>        <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">z</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">Eithers</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">left</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">right</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">]</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="k">new</span> <span class="nc">Eithers</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]())</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">),</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="o">::</span> <span class="n">xs</span>
</span><span class='line'>    <span class="o">})</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Eithers[A,B]</code> is a kind of <code>List[Either[A,B]]</code> that has been normalized so that consecutive <code>A</code>s and consecutive <code>B</code>s have been collapsed using their respective monoids. So it will contain alternating <code>A</code> and <code>B</code> values.</p>

<p>The only remaining problem is that a list full of identities is not exactly the same as the empty list. Remember the unit part of the homomorphism law:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">mzero</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">Eithers</span><span class="o">.</span><span class="n">empty</span>
</span><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">mzero</span><span class="o">)))</span> <span class="o">==</span> <span class="nc">Eithers</span><span class="o">.</span><span class="n">empty</span>
</span></code></pre></td></tr></table></div></figure>


<p>This doesn&rsquo;t hold at the moment. As Cale Gibbard points out in the comments below, <code>Eithers</code> is really the free monoid on the coproduct of <em>semigroups</em> <code>A</code> and <code>B</code>.</p>

<p>We could check each element as part of the normalization step to see if it <code>equals(zero)</code> for the given monoid. But that&rsquo;s a problem, as there are lots of monoids for which we can&rsquo;t write an <code>equals</code> method. For example, for the <code>Int =&gt; Int</code> monoid (with composition), we must make use of a notion like extensional equality, which we can&rsquo;t reasonably write in Scala.</p>

<p>So what we have to do is sort of wave our hands and say that equality on <code>Eithers[A,B]</code> is defined as whatever notion of equality we have for <code>A</code> and <code>B</code> respectively, with the rule that <code>es.fold[(A,B)]</code> defines the equality of <code>Eithers[A,B]</code>. For example, for monoids that really can have <code>Equal</code> instances:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">eithersEqual</span><span class="o">[</span><span class="kt">A:Monoid:Equal</span>,<span class="kt">B:Monoid:Equal</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">le</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">mzero</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">ri</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="o">)</span>
</span><span class='line'>      <span class="k">def</span> <span class="n">z</span><span class="o">(</span><span class="n">es</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>        <span class="n">es</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">le</span><span class="o">,</span> <span class="n">ri</span><span class="o">)(</span><span class="nc">Monoid</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)])</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">z</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span> <span class="o">===</span> <span class="n">z</span><span class="o">(</span><span class="n">ys</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we have to settle with a list full of zeroes being &ldquo;morally equivalent&rdquo; to an empty list. The difference is observable in e.g. the time it takes to traverse the list.</p>

<p>Setting that issue aside, <code>Eithers</code> is a monoid coproduct because it permits monoid homomorphisms from <code>A</code> and <code>B</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span><span class="o">)))</span> <span class="o">++</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a2</span><span class="o">))))</span> <span class="o">==</span>
</span><span class='line'>  <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a1</span> <span class="o">|+|</span> <span class="n">a2</span><span class="o">)))</span>
</span><span class='line'><span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span><span class="o">)))</span> <span class="o">++</span> <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b2</span><span class="o">))))</span> <span class="o">==</span>
</span><span class='line'>  <span class="nc">Eithers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b1</span> <span class="o">|+|</span> <span class="n">b2</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And we can implement the <code>fold</code> homomorphism:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span>,<span class="kt">Z:Monoid</span><span class="o">](</span>
</span><span class='line'>  <span class="n">es</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">es</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="n">mzero</span><span class="o">[</span><span class="kt">Z</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">z</span>
</span><span class='line'>      <span class="k">case</span> <span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">z</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And this time <code>fold</code> really is a homomorphism, and we can prove it by case analysis. Here&rsquo;s the law again:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">fold</span><span class="o">(</span><span class="n">e1</span><span class="o">)(</span><span class="n">f</span><span class="o">,</span><span class="n">g</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">fold</span><span class="o">(</span><span class="n">e2</span><span class="o">)(</span><span class="n">f</span><span class="o">,</span><span class="n">g</span><span class="o">))</span> <span class="o">==</span> <span class="n">fold</span><span class="o">(</span><span class="n">e1</span> <span class="o">++</span> <span class="n">e2</span><span class="o">)(</span><span class="n">f</span><span class="o">,</span><span class="n">g</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If either of <code>e1</code> or <code>e2</code> is empty then the result is the fold of the other, so those cases are trivial. If they are both nonempty, then they will have one of these forms:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">e1</span> <span class="k">=</span> <span class="o">[</span><span class="kt">...</span>, <span class="kt">Left</span><span class="o">(</span><span class="kt">a1</span><span class="o">)]</span>
</span><span class='line'><span class="n">e2</span> <span class="k">=</span> <span class="o">[</span><span class="kt">Left</span><span class="o">(</span><span class="kt">a2</span><span class="o">)</span>, <span class="kt">...</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">e1</span> <span class="k">=</span> <span class="o">[</span><span class="kt">...</span>, <span class="kt">Right</span><span class="o">(</span><span class="kt">b1</span><span class="o">)]</span>
</span><span class='line'><span class="n">e2</span> <span class="k">=</span> <span class="o">[</span><span class="kt">Right</span><span class="o">(</span><span class="kt">b2</span><span class="o">)</span>, <span class="kt">...</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">e1</span> <span class="k">=</span> <span class="o">[</span><span class="kt">...</span>, <span class="kt">Left</span><span class="o">(</span><span class="kt">a</span><span class="o">)]</span>
</span><span class='line'><span class="n">e2</span> <span class="k">=</span> <span class="o">[</span><span class="kt">Right</span><span class="o">(</span><span class="kt">b</span><span class="o">)</span>, <span class="kt">...</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">e1</span> <span class="k">=</span> <span class="o">[</span><span class="kt">...</span>, <span class="kt">Right</span><span class="o">(</span><span class="kt">b</span><span class="o">)]</span>
</span><span class='line'><span class="n">e2</span> <span class="k">=</span> <span class="o">[</span><span class="kt">Left</span><span class="o">(</span><span class="kt">a</span><span class="o">)</span>, <span class="kt">...</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the first two cases, on the right of the <code>==</code> sign in the law, we perform <code>a1 |+| a2</code> and <code>b1 |+| b2</code> respectively before concatenating. In the other two cases we simply concatenate the lists. The <code>++</code> method on <code>Eithers</code> takes care of doing this correctly for us. On the left of the <code>==</code> sign we fold the lists individually and they will be alternating applications of <code>f</code> and <code>g</code>. So then this law amounts to the fact that <code>f(a1 |+| a2) == f(a1) |+| f(a2)</code> in the first case, and the same for <code>g</code> in the second case. In the latter two cases this amounts to a homomorphism on <code>List</code>. So as long as <code>f</code> and <code>g</code> are homomorphisms, so is <code>fold(_)(f,g)</code>. Therefore, <code>Eithers[A,B]</code> really is a coproduct of <code>A</code> and <code>B</code>.</p>

<p>Since we have already convinced ourselves that <code>These</code> is a monoid coproduct, we could also simply show that there is a homomorphism from <code>Eithers</code> to <code>These</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">toThese</span><span class="o">[</span><span class="kt">A:Monoid</span>,<span class="kt">B:Monoid</span><span class="o">](</span><span class="n">es</span><span class="k">:</span> <span class="kt">Eithers</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">These</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">es</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="nc">Neither</span><span class="o">()</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">::</span> <span class="n">t</span> <span class="k">=&gt;</span> <span class="nc">This</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">toThese</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">::</span> <span class="n">t</span> <span class="k">=&gt;</span> <span class="nc">That</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">toThese</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Which would amount to proving that <code>(toThese(xs) |+| toThese(ys))</code> = <code>toThese(xs ++ ys)</code>.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">RÃºnar</span></span>

      




<time class='entry-date' datetime='2014-03-19'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:00 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://runarorama.github.com/blog/2014/03/19/monoid-morphisms-products-coproducts/" data-via="runarorama" data-counturl="http://runarorama.github.com/blog/2014/03/19/monoid-morphisms-products-coproducts/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/11/01/free-and-yoneda/" title="Previous Post: Free monads and the Yoneda lemma">&laquo; Free monads and the Yoneda lemma</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/09/18/at-long-last/" title="Next Post: At long last">At long last &raquo;</a>
      
    </p>
  </footer>
</article>
<section>
  <div id="comments">
    <h2>Comments</h2>
    <div id="header">
      Want to leave a comment? Visit <a href="https://github.com/runarorama/runarorama.github.com/issues/8"> this post&#8217;s issue page on GitHub</a>. You&#8217;ll need a GitHub account. This saves me from having to moderate comments. The comments you make there will appear on this page. If not, then GitHub is throttling API calls from your IP address.
    </div>
  </div>
<script type="text/javascript">
  function loadComments(data) {  
    for (var i=0; i<data.length; i++) {
      var cuser = data[i].user.login;
      var cuserlink = "https://www.github.com/" + cuser;
      var clink = "https://github.com/runarorama/runarorama.github.com/issues/8#issuecomment-" + data[i].url.substring(data[i].url.lastIndexOf("/")+1);
      var clink = "https://github.com/runarorama/runarorama.github.com/issues/8#issuecomment-" + data[i].url.substring(data[i].url.lastIndexOf("/")+1);
      var cbody = data[i].body_html;
      var cavatarlink = data[i].user.avatar_url;
      var cdate = (new Date(Date.parse(data[i].created_at))).toString();
      
      $("#comments").append("<div class='comment'><div class='commentheader'><div class='commentgravatar'>" + '<img src="' + cavatarlink + '" alt="" width="20" height="20">' + "</div><a class='commentuser' href=\""+ cuserlink + "\">" + cuser + "</a><a class='commentdate' href=\"" + clink + "\">" + cdate + "</a></div><div class='commentbody'>" + cbody + "</div></div>");
    }
  }
  $.ajax("https://api.github.com/repos/runarorama/runarorama.github.com/issues/8/comments", {
    headers: {Accept: "application/vnd.github.full+json"},
    dataType: "json",
    success: function(msg){
      loadComments(msg);
   }
  });
</script>
</section>

</div>

<aside class="sidebar">
  
    <section>
<h1>Read my book</h1>
<a href="http://manning.com/bjarnason"><img src="/images/FPinScalaCover.png" width="553px" height="694px"></a>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/12/freedom-and-forgetfulness/">Freedom and Forgetfulness</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/04/scala-comonad-tutorial-part-2/">Scala Comonad Tutorial, Part 2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/30/the-adjunction-that-induces-the-reader-monad/">An Adjunction That Induces the Reader Monad</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/23/a-scala-comonad-tutorial/">A Scala Comonad Tutorial, Part 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/18/easy-performance-wins-with-scalaz/">Easy Performance Wins With Scalaz</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/runarorama">@runarorama</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'runarorama',
            count: 4,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - RÃºnar Bjarnason -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
