
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>A Comonad of Graph Decompositions - Higher Order</title>
  <meta name="author" content="Rúnar Bjarnason">

  
  <meta name="description" content="I want to talk about a comonad that came up at work the other day. Actually, two of them, as the data structure in question is a comonad in at least &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://runarorama.github.com/blog/2016/04/02/a-comonad-of-graph-decompositions/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Higher Order" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script type="text/javascript" src="//use.typekit.net/fbs7fzv.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34544663-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  <link href="/stylesheets/datatable.css" media="screen, projection" rel="stylesheet" type="text/css" />
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Higher Order</a></h1>
  
    <h2>Philosophy and functional programming.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="runarorama.github.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">A Comonad of Graph Decompositions</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-04-02T10:02:54-07:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>10:02 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>I want to talk about a comonad that came up at <a href="http://innovation.verizon.com/">work</a> the other day. Actually, two of them, as the data structure in question is a comonad in at least two ways, and the issue that came up is related to the difference between those two comonads.</p>

<p>This post is sort of a continuation of the <a href="http://blog.higher-order.com/blog/2015/06/23/a-scala-comonad-tutorial/">Comonad Tutorial</a>, and we can call this &ldquo;part 3&rdquo;. I&rsquo;m going to assume the reader has a basic familiarity with comonads.</p>

<h2>Inductive Graphs</h2>

<p>At <a href="http://innovation.verizon.com/">work</a>, we develop and use a Scala library called <a href="http://github.com/oncue/quiver">Quiver</a> for working with <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics">graphs</a>). In this library, a graph is a recursively defined immutable data structure. A graph, with node IDs of type <code>V</code>, node labels <code>N</code>, and edge labels <code>E</code>, is constructed in one of two ways. It can be empty:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Or it can be of the form <code>c &amp; g</code>, where <code>c</code> is the <em>context</em> of one node of the graph and <code>g</code> is the rest of the graph with that node removed:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Context</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span>
</span><span class='line'>  <span class="n">inEdges</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[(</span><span class="kt">E</span>,<span class="kt">V</span><span class="o">)],</span>
</span><span class='line'>  <span class="n">vertex</span><span class="k">:</span> <span class="kt">V</span><span class="o">,</span>
</span><span class='line'>  <span class="n">label</span><span class="k">:</span> <span class="kt">N</span><span class="o">,</span>
</span><span class='line'>  <span class="n">outEdges</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[(</span><span class="kt">E</span>,<span class="kt">V</span><span class="o">)]</span>
</span><span class='line'><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="o">&amp;(</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>By the same token, we can decompose a graph on a particular node:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span>
</span><span class='line'><span class="n">v</span><span class="k">:</span> <span class="kt">V</span>
</span><span class='line'>
</span><span class='line'><span class="n">g</span> <span class="n">decomp</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Where a <code>GDecomp</code> is a <code>Context</code> for the node <code>v</code> (if it exists in the graph) together with the rest of the graph:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span><span class="n">ctx</span><span class="k">:</span> <span class="kt">Context</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">],</span> <span class="n">rest</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Recursive decomposition</h2>

<p>Let&rsquo;s say we start with a graph <code>g</code>, like this:</p>

<p><img src="/images/quiver/Quiver1.png" width="300" alt="Example graph" /></p>

<p>I&rsquo;m using an <em>undirected</em> graph here for simplification. An undirected graph is one in which the edges don&rsquo;t have a direction. In Quiver, this is represented as a graph where the &ldquo;in&rdquo; edges of each node are the same as its &ldquo;out&rdquo; edges.</p>

<p>If we decompose on the node <code>a</code>, we get a view of the graph from the perspective of <code>a</code>. That is, we&rsquo;ll have a <code>Context</code> letting us look at the label, vertex ID, and edges to and from <code>a</code>, and we&rsquo;ll also have the remainder of the graph, with the node <code>a</code> &ldquo;broken off&rdquo;:</p>

<p><img src="/images/quiver/decompa.png" width="400" alt="GDecomp on a" /></p>

<p>Quiver can arbitrarily choose a node for us, so we can look at the context of some &ldquo;first&rdquo; node:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">g</span><span class="o">.</span><span class="n">decompAny</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can keep decomposing the remainder recursively, to perform an arbitrary calculation over the entire graph:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">Context</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">],</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span>
</span><span class='line'><span class="n">b</span><span class="k">:</span> <span class="kt">B</span>
</span><span class='line'>
</span><span class='line'><span class="o">(</span><span class="n">g</span> <span class="n">fold</span> <span class="n">b</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
</span></code></pre></td></tr></table></div></figure>


<p>The implementation of <code>fold</code> will be something like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">g</span><span class="o">.</span><span class="n">decompAny</span> <span class="n">map</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">GDecomp</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">rest</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">b</span><span class="o">)(</span><span class="n">f</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span> <span class="n">getOrElse</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>For instance, if we wanted to count the edges in the graph <code>g</code>, we could do:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="o">(</span><span class="n">g</span> <span class="n">fold</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="o">(</span><span class="nc">Context</span><span class="o">(</span><span class="n">ins</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">outs</span><span class="o">),</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ins</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">outs</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">b</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The recursive decomposition will guarantee that our function doesn&rsquo;t see any given edge more than once. For the graph <code>g</code> above, <code>(g fold b)(f)</code> would look something like this:</p>

<p><img src="/images/quiver/fold.png" alt="Graph fold" /></p>

<h2>Graph Rotations</h2>

<p>Let&rsquo;s now say that we wanted to find the maximum <a href="https://en.wikipedia.org/wiki/Degree_(graph_theory">degree</a> of a graph. That is, find the highest number of edges to or from any node.</p>

<p>A first stab might be:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">maxDegree</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">g</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="o">(</span><span class="nc">Context</span><span class="o">(</span><span class="n">ins</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">outs</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">ins</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">outs</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="n">max</span> <span class="n">z</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But that would get the incorrect result. In our graph <code>g</code> above, the nodes <code>b</code>, <code>d</code>, and <code>f</code> have a degree of 3, but this fold would find the highest degree to be 2. The reason is that once our function gets to look at <code>b</code>, its edge to <code>a</code> has already been removed, and once it sees <code>f</code>, it has no edges left to look at.</p>

<p>This was the issue that came up at work. This behaviour of <code>fold</code> is both correct and useful, but it can be surprising. What we might expect is that instead of receiving successive decompositions, our function sees &ldquo;all rotations&rdquo; of the graph through the <code>decomp</code> operator:</p>

<p><img src="/images/quiver/rotations.png" alt="All rotations" /></p>

<p>That is, we often want to consider each node in the context of the entire graph we started with. In order to express that with <code>fold</code>, we have to decompose the original graph at each step:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">maxDegree</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">g</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="n">g</span><span class="o">.</span><span class="n">decompose</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">vertex</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">GDecomp</span><span class="o">(</span><span class="nc">Context</span><span class="o">(</span><span class="n">ins</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">outs</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>        <span class="n">ins</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">outs</span><span class="o">.</span><span class="n">size</span>
</span><span class='line'>    <span class="o">}.</span><span class="n">getOrElse</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="n">max</span> <span class="n">z</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But what if we could have a combinator that <em>labels each node with its context</em>?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">contextGraph</span><span class="o">(</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">Context</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">]</span>,<span class="kt">E</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Visually, that looks something like this:</p>

<p><img src="/images/quiver/duplicate.png" alt="All contexts" /></p>

<p>If we now fold over <code>contextGraph(g)</code> rather than <code>g</code>, we get to see the whole graph from the perspective of each node in turn. We can then write the <code>maxDegree</code> function like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">maxDegree</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">N</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">contextGraph</span><span class="o">(</span><span class="n">g</span><span class="o">).</span><span class="n">fold</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="n">z</span> <span class="n">max</span> <span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">ins</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">outs</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Two different comonads</h2>

<p>This all sounds suspiciously like a comonad! Of course, <code>Graph</code> itself is not a comonad, but <code>GDecomp</code> definitely is. The <code>counit</code> just gets the label of the node that&rsquo;s been <code>decomp</code>ed out:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">gdecompComonad</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">λ</span><span class="o">[</span><span class="kt">α</span> <span class="k">=&gt;</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">α</span>,<span class="kt">E</span><span class="o">]]]</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">label</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">cobind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">])(</span>
</span><span class='line'>                  <span class="n">f</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>cobind</code> can be implemented in one of two ways. There&rsquo;s the &ldquo;successive decompositions&rdquo; version:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">cobind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">])(</span>
</span><span class='line'>                <span class="n">f</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">GDecomp</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">g</span><span class="o">)),</span>
</span><span class='line'>          <span class="n">g</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">decompAny</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="nc">GDecomp</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=</span> <span class="n">cobind</span><span class="o">(</span><span class="k">_</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'>            <span class="n">c</span> <span class="o">&amp;</span> <span class="n">r</span>
</span><span class='line'>          <span class="o">}</span> <span class="n">getOrElse</span> <span class="n">empty</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Visually, it looks like this:</p>

<p><img src="/images/quiver/extend.png" alt="Extend over successive decompositions" /></p>

<p>It <em>exposes the substructure</em> of the graph by storing it in the labels of the nodes. It&rsquo;s very much like the familiar <code>NonEmptyList</code> comonad, which replaces each element in the list with the whole sublist from that element on.</p>

<p>So this is the comonad of <em>recursive folds over a graph</em>. Really its action is the same as as just <code>fold</code>. It takes a computation on one decomposition of the graph, and extends it to all sub-decompositions.</p>

<p>But there&rsquo;s another, comonad that&rsquo;s much more useful <em>as a comonad</em>. That&rsquo;s the comonad that works like <code>contextGraph</code> from before, except instead of copying the context of a node into its label, we copy the whole decomposition; both the context and the remainder of the graph.</p>

<p>That one looks visually more like this:</p>

<p><img src="/images/quiver/redecorate.png" alt="Extend over all rotations" /></p>

<p>Its <code>cobind</code> takes a computation focused on one node of the graph (that is, on a <code>GDecomp</code>), repeats that for every other decomposition of the original graph in turn, and stores the results in the respective node labels:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">cobind</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">])(</span>
</span><span class='line'>                <span class="n">f</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">A</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">GDecomp</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">orig</span> <span class="k">=</span> <span class="n">g</span><span class="o">.</span><span class="n">ctx</span> <span class="o">&amp;</span> <span class="n">g</span><span class="o">.</span><span class="n">rest</span>
</span><span class='line'>  <span class="nc">GDecomp</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">g</span><span class="o">)),</span>
</span><span class='line'>          <span class="n">rest</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">empty</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>            <span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">label</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">orig</span><span class="o">.</span><span class="n">decomp</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">vertex</span><span class="o">).</span><span class="n">get</span><span class="o">))</span> <span class="o">&amp;</span> <span class="n">acc</span>
</span><span class='line'>          <span class="o">})</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is useful for algorithms where we want to label every node with some information computed from its neighborhood. For example, some clustering algorithms start by assigning each node its own cluster, then repeatedly joining nodes to the most popular cluster in their immediate neighborhood, until a fixed point is reached.</p>

<p>As a simpler example, we could take the average value for the labels of neighboring nodes, to apply something like a low-pass filter to the whole graph:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">lopass</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">E</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">Int</span>,<span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">Graph</span><span class="o">[</span><span class="kt">V</span>,<span class="kt">Int</span>,<span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="n">g</span><span class="o">.</span><span class="n">decompAny</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">d</span> <span class="k">=&gt;</span> <span class="n">cobind</span><span class="o">(</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">neighbors</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">inEdges</span> <span class="o">++</span> <span class="n">x</span><span class="o">.</span><span class="n">outEdges</span><span class="o">).</span><span class="n">map</span> <span class="o">{</span> <span class="n">n</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="n">g</span><span class="o">.</span><span class="n">decomp</span><span class="o">(</span><span class="n">n</span><span class="o">).</span><span class="n">get</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">label</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="o">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">sum</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}}</span> <span class="n">getOrElse</span> <span class="n">g</span>
</span></code></pre></td></tr></table></div></figure>


<p>The difference between these two comonad instances is essentially the same as the difference between <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/NonEmptyList.scala"><code>NonEmptyList</code></a> and the nonempty list <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Zipper.scala"><code>Zipper</code></a>.</p>

<p>It&rsquo;s this latter &ldquo;decomp zipper&rdquo; comonad that I decided to ultimately include as the <code>Comonad</code> instance for <code>quiver.GDecomp</code>.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Rúnar</span></span>

      




<time class='entry-date' datetime='2016-04-02T10:02:54-07:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>10:02 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/comonads/'>comonads</a>, <a class='category' href='/blog/categories/scala/'>scala</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://runarorama.github.com/blog/2016/04/02/a-comonad-of-graph-decompositions/" data-via="runarorama" data-counturl="http://runarorama.github.com/blog/2016/04/02/a-comonad-of-graph-decompositions/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/10/12/freedom-and-forgetfulness/" title="Previous Post: Freedom and Forgetfulness">&laquo; Freedom and Forgetfulness</a>
      
      
    </p>
  </footer>
</article>
<section>
  <div id="comments">
    <h2>Comments</h2>
    <div id="header">
      Want to leave a comment? Visit <a href="https://github.com/runarorama/runarorama.github.com/issues/22"> this post&#8217;s issue page on GitHub</a>. You&#8217;ll need a GitHub account. This saves me from having to moderate comments. The comments you make there will appear on this page. If not, then GitHub is throttling API calls from your IP address.
    </div>
  </div>
<script type="text/javascript">
  function loadComments(data) {  
    for (var i=0; i<data.length; i++) {
      var cuser = data[i].user.login;
      var cuserlink = "https://www.github.com/" + cuser;
      var clink = "https://github.com/runarorama/runarorama.github.com/issues/22#issuecomment-" + data[i].url.substring(data[i].url.lastIndexOf("/")+1);
      var clink = "https://github.com/runarorama/runarorama.github.com/issues/22#issuecomment-" + data[i].url.substring(data[i].url.lastIndexOf("/")+1);
      var cbody = data[i].body_html;
      var cavatarlink = data[i].user.avatar_url;
      var cdate = (new Date(Date.parse(data[i].created_at))).toString();
      
      $("#comments").append("<div class='comment'><div class='commentheader'><div class='commentgravatar'>" + '<img src="' + cavatarlink + '" alt="" width="20" height="20">' + "</div><a class='commentuser' href=\""+ cuserlink + "\">" + cuser + "</a><a class='commentdate' href=\"" + clink + "\">" + cdate + "</a></div><div class='commentbody'>" + cbody + "</div></div>");
    }
  }
  $.ajax("https://api.github.com/repos/runarorama/runarorama.github.com/issues/22/comments", {
    headers: {Accept: "application/vnd.github.full+json"},
    dataType: "json",
    success: function(msg){
      loadComments(msg);
   }
  });
</script>
</section>

</div>

<aside class="sidebar">
  
    <section>
<h1>Read my book</h1>
<a href="http://manning.com/bjarnason"><img src="/images/FPinScalaCover.png" width="553px" height="694px"></a>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/04/02/a-comonad-of-graph-decompositions/">A Comonad of Graph Decompositions</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/12/freedom-and-forgetfulness/">Freedom and Forgetfulness</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/04/scala-comonad-tutorial-part-2/">Scala Comonad Tutorial, Part 2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/30/the-adjunction-that-induces-the-reader-monad/">An Adjunction That Induces the Reader Monad</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/22/a-scala-comonad-tutorial/">A Scala Comonad Tutorial, Part 1</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/runarorama">@runarorama</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'runarorama',
            count: 4,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Rúnar Bjarnason -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
