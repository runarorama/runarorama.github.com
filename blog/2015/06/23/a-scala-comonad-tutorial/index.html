
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>A Scala Comonad Tutorial, Part 1 - Higher Order</title>
  <meta name="author" content="RÃºnar Bjarnason">

  
  <meta name="description" content="In chapter 11 of our book, we talk about monads in Scala. This finally names a pattern that the reader has seen throughout the book and gives it a &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://runarorama.github.com/blog/2015/06/23/a-scala-comonad-tutorial/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Higher Order" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script type="text/javascript" src="//use.typekit.net/fbs7fzv.js"></script>
<script type="text/javascript">try{Typekit.load();}catch(e){}</script>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-34544663-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  <link href="/stylesheets/datatable.css" media="screen, projection" rel="stylesheet" type="text/css" />
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Higher Order</a></h1>
  
    <h2>Philosophy and functional programming.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="runarorama.github.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">A Scala Comonad Tutorial, Part 1</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-23T01:15:47-04:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>1:15 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>In chapter 11 of <a href="http://manning.com/bjarnason">our book</a>, we talk about monads in Scala. This finally names a pattern that the reader has seen throughout the book and gives it a formal structure. We also give some intuition for what it <em>means</em> for something to be a monad. Once you have this concept, you start recognizing it everywhere in the daily business of programming.</p>

<p>Today I want to talk about <em>comonads</em>, which are the dual of monads. The utility of comonads in everyday life is not quite as immediately obvious as that of monads, but they definitely come in handy sometimes. Particularly in applications like image processing and scientific computation.</p>

<h2>A monad, upside-down</h2>

<p>Let&rsquo;s remind ourselves of what a monad is. A monad is a functor, which just means it has a <code>map</code> method:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This has to satisfy the law that <code>map(x)(a =&gt; a) == x</code>, i.e. that mapping the identity function over our functor is a no-op.</p>

<h3>Monads</h3>

<p>A monad is a functor <code>M</code> equipped with two additional polymorphic functions; One from <code>A</code> to <code>M[A]</code> and one from <code>M[M[A]]</code> to <code>M[A]</code>.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">mma</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Recall that <code>join</code> has to satisfy associativity, and <code>unit</code> has to be an identity for <code>join</code>.</p>

<p>In Scala a monad is often stated in terms of <code>flatMap</code>, which is <code>map</code> followed by <code>join</code>. But I find this formulation easier to explain.</p>

<p>Every monad has the above operations, the so-called <em>proper morphisms</em> of a monad, and may also bring to the table some <em>nonproper morphisms</em> which give the specific monad some additional capabilities.</p>

<h4>Reader monad</h4>

<p>For example, the <code>Reader</code> monad brings the ability to ask for a value:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Reader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">R</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">ask</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span><span class="k">:</span> <span class="kt">Reader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Reader</span><span class="o">(</span><span class="n">r</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The meaning of <code>join</code> in the reader monad is to pass the same context of type <code>R</code> to both the outer scope and the inner scope:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">Reader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">Reader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">]])</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">Reader</span><span class="o">((</span><span class="n">c</span><span class="k">:</span><span class="kt">R</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="o">).</span><span class="n">run</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Writer monad</h4>

<p>The <code>Writer</code> monad has the ability to write a value on the side:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Writer</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">A</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">log</span><span class="k">:</span> <span class="kt">W</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">tell</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">A</span><span class="o">](</span><span class="n">w</span><span class="k">:</span> <span class="kt">W</span><span class="o">)</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Writer</span><span class="o">((),</span> <span class="n">w</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The meaning of <code>join</code> in the writer monad is to concatenate the &ldquo;log&rdquo; of written values using the monoid for <code>W</code> (this is using the <code>Monoid</code> class from <a href="http://github.com/scalaz/scalaz">Scalaz</a>):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">W:Monoid</span>,<span class="kt">A</span><span class="o">](</span><span class="n">w</span><span class="k">:</span> <span class="kt">Writer</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">Writer</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">A</span><span class="o">]])</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">Writer</span><span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="o">,</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">W</span><span class="o">].</span><span class="n">append</span><span class="o">(</span><span class="n">w</span><span class="o">.</span><span class="n">log</span><span class="o">,</span> <span class="n">w</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">log</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And the meaning of <code>unit</code> is to write the &ldquo;empty&rdquo; log:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">unit</span><span class="o">[</span><span class="kt">W:Monoid</span>,<span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Writer</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">W</span><span class="o">].</span><span class="n">zero</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>State monad</h4>

<p>The <code>State</code> monad can both get and set the state:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">S</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="o">))</span>
</span><span class='line'><span class="k">def</span> <span class="n">put</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">State</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">((),</span> <span class="n">s</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The meaning of <code>join</code> in the state monad is to give the outer action an opportunity to get and put the state, then do the same for the inner action, making sure any subsequent actions see the changes made by previous ones.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">run</span><span class="k">:</span> <span class="kt">S</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">S</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">](</span><span class="n">v1</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">State</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="nc">State</span><span class="o">(</span><span class="n">s1</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="o">(</span><span class="n">v2</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="k">=</span> <span class="n">v1</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">v2</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">s2</span><span class="o">)</span>
</span><span class='line'>  <span class="o">})</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Option monad</h4>

<p>The <code>Option</code> monad can terminate without an answer:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">none</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&rsquo;s enough examples of monads. Let&rsquo;s now turn to comonads.</p>

<h2>Comonads</h2>

<p>A comonad is the same thing as a monad, only backwards:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">W</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">W</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">w</span><span class="k">:</span> <span class="kt">W</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">wa</span><span class="k">:</span> <span class="kt">W</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">W</span><span class="o">[</span><span class="kt">W</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that counit is pronounced &ldquo;co-unit&rdquo;, not &ldquo;cow-knit&rdquo;. It&rsquo;s also sometimes called <code>extract</code> because it allows you to get a value of type <code>A</code> <em>out of</em> a <code>W[A]</code>. While with monads you can generally only put values in and not get them out, with comonads you can generally only get them out and not put them in.</p>

<p>And instead of being able to <code>join</code> two levels of a monad into one, we can <code>duplicate</code> one level of a comonad into two.</p>

<p>Kind of weird, right? This also has to obey some laws. We&rsquo;ll get to those later on, but let&rsquo;s first look at some actual comonads.</p>

<h3>The identity comonad</h3>

<p>A simple and obvious comonad is the dumb wrapper (the identity comonad):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Id</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">counit</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">a</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Id</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Id</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This one is also the identity <em>monad</em>. <code>Id</code> doesn&rsquo;t have any functionality other than the proper morphisms of the (co)monad and is therefore not terribly interesting. We can get the value out with our <code>counit</code>, and we can vacuously <code>duplicate</code> by decorating our existing <code>Id</code> with another layer.</p>

<h3>The reader comonad</h3>

<p>There&rsquo;s a comonad with the same capabilities as the reader monad, namely that it allows us to ask for a value:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">](</span><span class="n">extract</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ask</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coreader</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">extract</span><span class="o">),</span> <span class="n">ask</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Coreader</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">ask</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>It should be obvious how we can give a <code>Comonad</code> instance for this (I&rsquo;m using the <a href="https://github.com/non/kind-projector">Kind Projector compiler plugin</a> to make the syntax look a little nicer than Vanilla Scala):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">coreaderComonad</span><span class="o">[</span><span class="kt">R</span><span class="o">]</span><span class="k">:</span> <span class="kt">Comonad</span><span class="o">[</span><span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">Comonad</span><span class="o">[</span><span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="n">c</span> <span class="n">map</span> <span class="n">f</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">counit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">extract</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">duplicate</span><span class="o">(</span><span class="n">c</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="n">c</span><span class="o">.</span><span class="n">duplicate</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Arguably, this is much more straightforward in Scala than the reader monad. In the reader <em>monad</em>, the <code>ask</code> function is the identity function. That&rsquo;s saying &ldquo;once the <code>R</code> value is available, return it to me&rdquo;, making it available to subsequent <code>map</code> and <code>flatMap</code> operations. But in <code>Coreader</code>, we don&rsquo;t have to pretend to have an <code>R</code> value. It&rsquo;s just right there and we can look at it.</p>

<p>So <code>Coreader</code> just wraps up some value of type <code>A</code> together with some additional context of type <code>R</code>. Why is it important that this is a <em>comonad</em>? What is the meaning of <code>duplicate</code> here?</p>

<p>To see the meaning of <code>duplicate</code>, notice that it puts the whole <code>Coreader</code> in the value slot (in the <code>extract</code> portion). So any subsequent <code>extract</code> or <code>map</code> operation will be able to observe both the value of type <code>A</code> and the context of type <code>R</code>. We can think of this as passing the context along to those subsequent operations, which is analogous to what the reader monad does.</p>

<p>In fact, just like <code>map</code> followed by <code>join</code> is usually expressed as <code>flatMap</code>, by the same token <code>duplicate</code> followed by <code>map</code> is usually expressed as a single operation, <code>extend</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">](</span><span class="n">extract</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">ask</span><span class="k">:</span> <span class="kt">R</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="o">...</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">extend</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Coreader</span><span class="o">[</span><span class="kt">R</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">duplicate</span> <span class="n">map</span> <span class="n">f</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that the type signature of <code>extend</code> looks like <code>flatMap</code> with the direction of <code>f</code> reversed. And just like we can chain operations in a monad using <code>flatMap</code>, we can chain operations in a comonad using <code>extend</code>. In <code>Coreader</code>, <code>extend</code> is making sure that <code>f</code> can use the context of type <code>R</code> to produce its <code>B</code>.</p>

<p>Chaining operations this way using <code>flatMap</code> in a monad is sometimes called <em>Kleisli composition</em>, and chaining operations using <code>extend</code> in a comonad is called <em>coKleisli</em> composition (or just Kleisli composition in a comonad).</p>

<p>The name <code>extend</code> refers to the fact that it takes a &ldquo;local&rdquo; computation that operates on some structure and &ldquo;extends&rdquo; that to a &ldquo;global&rdquo; computation that operates on all substructures of the larger structure.</p>

<h3>The writer comonad</h3>

<p>Just like the writer monad, the writer comonad can append to a log or running tally using a monoid. But instead of keeping the log always available to be appended to, it uses the same trick as the reader monad by building up an operation that gets executed once a log becomes available:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Cowriter</span><span class="o">[</span><span class="kt">W:Monoid</span>,<span class="kt">A</span><span class="o">](</span><span class="n">tell</span><span class="k">:</span> <span class="kt">W</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Cowriter</span><span class="o">(</span><span class="n">tell</span> <span class="n">andThen</span> <span class="n">f</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">extract</span> <span class="k">=</span> <span class="n">tell</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">W</span><span class="o">].</span><span class="n">zero</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">duplicate</span><span class="k">:</span> <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>, <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Cowriter</span><span class="o">(</span><span class="n">w1</span> <span class="k">=&gt;</span> <span class="nc">Cowriter</span><span class="o">(</span><span class="n">w2</span> <span class="k">=&gt;</span> <span class="n">tell</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">W</span><span class="o">].</span><span class="n">append</span><span class="o">(</span><span class="n">w1</span><span class="o">,</span> <span class="n">w2</span><span class="o">))))</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">extend</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cowriter</span><span class="o">[</span><span class="kt">W</span>,<span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">duplicate</span> <span class="n">map</span> <span class="n">f</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note that <code>duplicate</code> returns a whole <code>Cowriter</code> from its constructed <code>run</code> function, so the meaning is that subsequent operations (composed via <code>map</code> or <code>extend</code>) have access to exactly one <code>tell</code> function, which appends to the existing log or tally. For example, <code>foo.extend(_.tell("hi"))</code> will append <code>"hi"</code> to the log of <code>foo</code>.</p>

<h2>Comonad laws</h2>

<p>The comonad laws are analogous to the monad laws:</p>

<ol>
<li>Left identity: <code>wa.duplicate.extract == wa</code></li>
<li>Right identity: <code>wa.extend(extract) == wa</code></li>
<li>Associativity: <code>wa.duplicate.duplicate == wa.extend(duplicate)</code></li>
</ol>


<p>It can be hard to get an intuition for what these laws <em>mean</em>, but in short they mean that (co)Kleisli composition in a comonad should be associative and that <code>extract</code> (a.k.a. <code>counit</code>) should be an identity for it.</p>

<p>Very informally, both the monad and comonad laws mean that we should be able to compose our programs top-down or bottom-up, or any combination thereof, and have that mean the same thing regardless.</p>

<h2>Next time&hellip;</h2>

<p>In <a href="http://blog.higher-order.com/blog/2015/10/04/scala-comonad-tutorial-part-2/">part 2</a> we&rsquo;ll look at some more examples of comonads and follow some of the deeper connections. Like what&rsquo;s the relationship between the reader monad and the reader comonad, or the writer monad and the writer comonad? They&rsquo;re not identical, but they seem to do all the same things. Are they equivalent? Isomorphic? Something else?</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">RÃºnar</span></span>

      




<time class='entry-date' datetime='2015-06-23T01:15:47-04:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2015</span></span> <span class='time'>1:15 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://runarorama.github.com/blog/2015/06/23/a-scala-comonad-tutorial/" data-via="runarorama" data-counturl="http://runarorama.github.com/blog/2015/06/23/a-scala-comonad-tutorial/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/06/18/easy-performance-wins-with-scalaz/" title="Previous Post: Easy performance wins with Scalaz">&laquo; Easy performance wins with Scalaz</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/09/30/the-adjunction-that-induces-the-reader-monad/" title="Next Post: An adjunction that induces the reader monad">An adjunction that induces the reader monad &raquo;</a>
      
    </p>
  </footer>
</article>
<section>
  <div id="comments">
    <h2>Comments</h2>
    <div id="header">
      Want to leave a comment? Visit <a href="https://github.com/runarorama/runarorama.github.com/issues/18"> this post&#8217;s issue page on GitHub</a>. You&#8217;ll need a GitHub account. This saves me from having to moderate comments. The comments you make there will appear on this page. If not, then GitHub is throttling API calls from your IP address.
    </div>
  </div>
<script type="text/javascript">
  function loadComments(data) {  
    for (var i=0; i<data.length; i++) {
      var cuser = data[i].user.login;
      var cuserlink = "https://www.github.com/" + cuser;
      var clink = "https://github.com/runarorama/runarorama.github.com/issues/18#issuecomment-" + data[i].url.substring(data[i].url.lastIndexOf("/")+1);
      var clink = "https://github.com/runarorama/runarorama.github.com/issues/18#issuecomment-" + data[i].url.substring(data[i].url.lastIndexOf("/")+1);
      var cbody = data[i].body_html;
      var cavatarlink = data[i].user.avatar_url;
      var cdate = (new Date(Date.parse(data[i].created_at))).toString();
      
      $("#comments").append("<div class='comment'><div class='commentheader'><div class='commentgravatar'>" + '<img src="' + cavatarlink + '" alt="" width="20" height="20">' + "</div><a class='commentuser' href=\""+ cuserlink + "\">" + cuser + "</a><a class='commentdate' href=\"" + clink + "\">" + cdate + "</a></div><div class='commentbody'>" + cbody + "</div></div>");
    }
  }
  $.ajax("https://api.github.com/repos/runarorama/runarorama.github.com/issues/18/comments", {
    headers: {Accept: "application/vnd.github.full+json"},
    dataType: "json",
    success: function(msg){
      loadComments(msg);
   }
  });
</script>
</section>

</div>

<aside class="sidebar">
  
    <section>
<h1>Read my book</h1>
<a href="http://manning.com/bjarnason"><img src="/images/FPinScalaCover.png" width="553px" height="694px"></a>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/04/02/a-comonad-of-graph-decompositions/">A Comonad of Graph Decompositions</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/12/freedom-and-forgetfulness/">Freedom and Forgetfulness</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/04/scala-comonad-tutorial-part-2/">Scala Comonad Tutorial, Part 2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/30/the-adjunction-that-induces-the-reader-monad/">An Adjunction That Induces the Reader Monad</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/23/a-scala-comonad-tutorial/">A Scala Comonad Tutorial, Part 1</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/runarorama">@runarorama</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'runarorama',
            count: 4,
            skip_forks: false,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - RÃºnar Bjarnason -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
